---
title: "Origo"
author: "Adela"
date: "2023-01-09"
output: html_document
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(mapview)
library(leaflet)
```

## Testing LIST 0.6
Here I test to extract people out of our aggregate datasets LIST nad LIRE respectively
```{r}
LIST <- st_read_parquet("../data/large_data/LIST_v0-6.parquet")

# Check for the extistence of people column in LIST 
colnames(LIST)
LIST$people[1:2]
which(is.na(LIST$people)) # some 33555 inscriptions do not have a person associated 

# Check you have loaded origo parquet
unique(origo$hd_nr)

# Extract non-missing people from the origo subset
people_or_unnested <- LIST %>% 
  dplyr::select(LIST.ID, EDH.ID, people) %>% 
  filter(EDH.ID %in% unique(origo$hd_nr)) %>% 
  unpack(people)  %>% 
  unnest_wider(people, simplify = TRUE) %>% 
  unnest_longer(c(person_id,name, cognomen, nomen, supernomen, gender, praenomen, `age: years`, `age: months`, `age: days`, `age: hours`, status, occupation, tribus, origo)) %>% 
  # selecting only inscriptions that have people
  filter(!is.na(person_id))

# See who has "origo" - 2288 individuals
people_or_unnested %>% 
  filter(!is.na(origo))

# Extract non-missing people from LIRE
list_people_unnest <- LIST %>% 
  dplyr::select(LIST.ID, EDH.ID, people) %>% 
  filter(!is.na(people)) %>% 
  unpack(people)  %>% 
  unnest_wider(people, simplify = TRUE) %>% 
  unnest_longer(c(person_id,name, cognomen, nomen, supernomen, gender, praenomen, `age: years`, `age: months`, `age: days`, `age: hours`, status, occupation, tribus, origo)) %>% 
  # selecting only inscriptions that have people
  filter(!is.na(person_id))

```



The script below should be run in sequence to R_EXPLORING PEOPLE where the necessary data> EDH tibble are created and people unnested.
There is the origo and then lots of findspot data, e.g., findspot_ancient, findspot_modern, their cleaned versions and findspot_certainty, 

```{r}
EDH_people <- readRDS("../data/large_data/edh_people21.rds")
head(EDH_people) # EDH_people comes from R_EXPLORING_PEOPLE script 
EDH_people %>% 
  select(matches("cognomen|findspot|origo|province|geo"))
colnames(LIST)
LIST %>% 
  st_drop_geometry() %>% 
  select(matches("ID|geo|findspot|place")) %>% 
  #distinct(place) %>% # 22 691 unique places
  distinct(findspot_clean) #%>% 
  pull()
  
  LIST %>% 
    st_drop_geometry() %>% 
    filter(str_detect(findspot_clean, regex("Forum Vetus",ignore_case = TRUE))) %>% 
    select(EDH.ID, findspot_clean, findspot_ancient_clean)
  
  # Isthm and 
  LIST %>% 
    st_drop_geometry() %>% 
    filter(str_detect(findspot_clean, regex("brunnen",ignore_case = TRUE))) %>% 
    select(EDH.ID, findspot_clean, findspot_ancient_clean)
```
There is origo in the people attribute and additional 14 columns with spatial/geographic information in the enriched EDH attributes. Except for origo, they originate from the inscription itself, describing its provenance or context of discovery.


# Origo in EDH people
```{r}
origo<- as.data.frame(EDH_people$origo) 
origo

EDH_people %>% 
  filter(!is.na(origo)) %>% 
  #mutate(clean_origo = str_replace_all(string = combined, pattern = "\\?", replacement = "")) %>%
  count(origo, sort=TRUE)
```
# Origo in EDH_person_data.csv
```{r}
EDH_persons <- read_csv("../data/edh_data_pers.csv")
tail(EDH_persons)

# percentage of persons with origo
sum(!is.na(EDH_persons$origo))/sum(is.na(EDH_persons$origo))

# persons with origo
EDH_persons %>% 
  filter(!is.na(origo))

# unique origo places
EDH_persons %>% 
  filter(!is.na(origo)) %>% 
  count(origo, sort=TRUE)

# inscriptions with origo
EDH_persons %>% 
  filter(!is.na(origo)) %>% 
  distinct(hd_nr)

# insriptions total
EDH_persons %>% 
  count(hd_nr)

2217/46801
2217/nrow(LIST)
```

## How many people have origin in their inscription?

```{r}
EDH_people %>% 
  select(origo) %>% 
  filter(!is.na(origo)) %>% 
  distinct()

```

The answer is 2648 people out of 92427, which is barely 3% , or precisely: `2648/92427*100` %
These 2648 people originate from 1889 distinct places. For these we can pin a point in the map for 676 locations or 36%.

## What is the men:women ratio?
```{r}
EDH_people %>% 
    group_by(gender) %>%
  summarize(cnt = n()) %>% 
  mutate(ratio = round(cnt/sum(cnt)*100, 1))

EDH_people %>% 
  select(origo, gender) %>% 
  filter(!is.na(origo)) %>% 
  group_by(gender) %>%
  summarize(cnt = n()) %>% 
  mutate(ratio = round(cnt/sum(cnt)*100, 1))
```
Declarations of origo are less frequent among women then men. The ratio in EDH is ca 15:65 women to men, while in the corpus with origo the ratio is even more skewed with only 5% of women and 85% of men (with the remaining 10-20% being NA values)

## What kind of inscription has origo
To explore other inscription-derived attributes of people iwth origin, we need to use EDH_full - a joined dataset of origo and EDH attributes
```{r}
# number of inscriptions that have origo (whether geocoded or not)
EDH_people %>% 
  filter(!is.na(origo)) %>% 
  group_by(id) %>% 
  tally()

EDH_full %>%  # use EDH_full
  filter(!is.na(origo)) %>% 
  count(type_of_inscription_clean, sort=T) %>% 
  mutate(ratio = round(n/(sum(n)/100),2))

EDH_full %>%  # was EDH_full
  filter(!is.na(origo)) %>% 
  count(type_of_inscription_clean, sort=T) %>% 
  mutate(ratio = round(n/(sum(n)/100),2)) %>% 
  slice(c(1:4,6:8)) %>%   # grab the first seven categories
  ggplot(aes(x = "", y = ratio, fill = type_of_inscription_clean)) +
  geom_bar(stat="identity", width=2, color = "white") +
  coord_polar("y", start=0.5)+
  labs(fill = paste0("Inscription Type (n = 2648)"))+
  theme_void() # remove background, grid, numeric labels

```

Expressions of 'origo' feature mostly in epitaphs followed by honorific and votive inscriptions, lists and military diplomas. Epitaphs are personal, while most others can be also more public.

## What status did the people have?
Some people declare multiple statuses so this is the maximum broadest picture.
```{r}
# Check the contents of the 'status' column in the EDH_full
colnames(EDH_full)
EDH_full$status

# Subset to inscriptions with origo
has_origo <- EDH_full %>% 
  filter(!is.na(origo))
# Parse the contents into a separate dataframe
status <- has_origo  %>% 
  pull(status) %>% 
  str_split_fixed(pattern = ";", n = 3) %>% 
  as.data.frame()

# str_split_fixed(has_origo$status, ";", n = 3) %>%
#   as.data.frame() -> status

# Summarize the status
status_counts <- status %>% 
  cbind(combined = c(status$V1,status$V2,status$V3)) %>% 
  filter(combined != "") %>% 
  mutate(combined_clean = str_replace_all(string = combined, pattern = "\\?", replacement = "")) %>% 
  mutate(combined_clean = str_replace_all(string = combined_clean, pattern = "^ ", replacement = "")) %>% 
  count(combined_clean, sort=TRUE) %>% 
  mutate(log = log10(n), perc = n/sum(n)*100)

status_counts 
```

```{r}
status_counts %>% 
  mutate(combined_clean = reorder(combined_clean, n)) %>% 
  ggplot(aes(y=combined_clean, x=log, fill=combined_clean)) +
  geom_col(width=0.8, show.legend = FALSE) +
  coord_cartesian( ylim = c(0,10)) +
  labs(x = "Number of instances (log10)", y = "Status category", title = "Status references in the EDH dataset with origo", subtitle = ggtitle(paste("n =", nrow(has_origo), "inscriptions"))) +
  geom_label(aes(label= n), show.legend = FALSE) +
  theme_linedraw(base_size = 12) +
  theme_minimal()
```


## What is the findspot vs origo - switch to parquet !
```{r}
EDH_full %>% 
  filter(!is.na(origo) & type_of_inscription_clean == "epitaph") %>% 
  select(origo, findspot_ancient_clean) %>% 
  count(findspot_ancient_clean, origo, sort=T)
``` 


# Birth to Death Distance Analysis

So this is tricky as the `origo` is an ancient placename that does not come with coordinates, can be ambiguous, poorly spelled and without a physical referent!
Also, out of 92427 people in the EDH inscriptions, only 2648 (2.8%) mention origo in their message
Out of these 2648 locations there are 673 unique geocoded placenames.

## Bring in json data from sciencedk geocoded by Vojtech in 2021 
in py_geocode_origo
The json output has 2648 rows just like there are people with origo in the EDH dataset, however only 676 unique origo ( presumed birthplace) locations have been successfully geocoded, adn three of those lack lat/long of the findspot (presumed deathplace)

```{r}
# geoorigo <- jsonlite::fromJSON("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/EDH_origo_geo_2021-08-24.json")

# all 92427 people records with all attributes incl origo
geoorigo <- as_tibble(geoorigo)  
names(geoorigo)


# 2648 records of people with origo
has_origo_sm <- geoorigo %>%   
  select(matches("person_id|origo|long|lat|findspot|gender|status|province|country")) %>% 
  filter(origo != "NULL")

# 676 successfully geocoded origo_geo records 
EDH_origo <- has_origo_sm %>% 
  filter(origo_geo != "NULL")

```
Format of EDH_origo is annoying All the columns are lists which is annoying. Let's unlist all of them
```{r unlist}
unnest_all <- function(df) {
  list_columns <- df %>% keep(is.list) %>% names()
  
  if (length(list_columns) == 0) {
    return(df)
  }

  for (list_column in list_columns) {
    df <-
      df %>%
      unnest_wider(list_column, names_sep = "_")
  }
  unnest_all(df)
}

EDH_origo <- unnest_all(EDH_origo)
names(EDH_origo) <- gsub("_1","", names(EDH_origo))
EDH_origo

# Save the 
# saveRDS(EDH_origo, "../data/origo_df.rds") 
# EDH_origo <- read_rds("../data/origo_df.rds")
# EDH_origo
```

### Spatialize origo - Create Birth places

Eliminate missing coordinates
```{r}
EDH_origo[which(is.na(EDH_origo$longitude)),]  # points are missing lat/long, one legit, one Aquincum and one laggachen

EDH_origo <- EDH_origo %>% 
  filter(!is.na(longitude))
```

```{r spatialize}
library(sf)

EDHg_origo <- EDH_origo %>% 
  st_as_sf(coords = c("origo_geo_2", "origo_geo"), crs = 4326)

EDHg_findspot <- EDH_origo %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

#Save
# saveRDS(EDHg_origo, "../data/EDH_origo_sp.rds")
# saveRDS(EDHg_findspot, "../data/EDH_origo_findpot_sp.rds")
```

Let's now draw linestrings between the origin and final findspot, our proxies between the birth and death places of each of the 676 persons here.
We need a matrix of both sets of points

## Create Birth-Death place linestrings

We connect the origo (birthplace) column coordinates with findspot (deathplace) by great circles in geodetic space

```{r}
lines <- st_sfc(mapply(function(a,b){
  st_cast(st_union(a,b),"LINESTRING")}, 
  EDHg_origo$geometry, EDHg_findspot$geometry, SIMPLIFY=FALSE))

st_crs(lines) <- 4326

library(mapview)
mapview(lines)
```


## Calculate as-the-crow-flies distances
Let's calculate great circle distances and differentiate lines by length

```{r line-length}
# Convert lines to sf and calculate length
lines_sf <- st_as_sf(lines)
lines_sf$length <- st_length(lines)

# Convert to km - but beware it is still declared as m
lines_sf$length_km <- unclass(lines_sf$length/1000)

# See the length visualized
mapview(lines_sf, zcol = "length_km")
```
### Let's see the range of distances travelled
If we connect the birth and death places with great circle distances, ignoring roads and other barriers as well as sea travel. All distances are wrong in similar way. Yet, we can assume that dying 500km away from home is serious. So even if it is only 3% people, the distances are substantial and that may be why origo is  mentioned
If the Romans could fly as the crows, these would be their ranges.
```{r}
lines_sf$length_km %>% 
  hist( main = "Great Circle distances from birth region to death region", xlab = "km")
```
```{r}
sum(unclass(lines_sf$length_km)) / nrow(EDH_origo) #in kilometers not meters
```

## Walk around the Empire with MapBoxAPIe
Let's see which origins are most common. 
```{r}
EDH_origo %>% 
  group_by(origo_clean) %>% 
  tally() %>% arrange(desc(n))

```
The most frequent starting places are Remesiana (41), Ratiaria(32), Verona(28), Roma(27) and Savaria(25).

### A test minidataset
And if we were to reduce data to the top 5

```{r}
top5 <- EDH_origo %>% 
  group_by(origo_clean) %>% 
  tally() %>% arrange(desc(n)) %>% slice(1:5)
EDHg_origo %>% 
  filter(origo_clean %in% top5$origo_clean) %>% 
  select(origo_clean, findspot_modern) %>%
  group_by(origo_clean) %>% 
  distinct(findspot_modern) %>% 
  arrange(origo_clean)
```
Remesiana people all die/dedicate in Kostolac, but natives of Rome, Verona and Savaria go to many different places.

### Starting mapboxAPI and its directions module
```{r}
library(mapboxapi)

?mb_directions
startplace <- "Verona"

# a pair of coordinates is needed for the origin and destination
route_dir1 <- mb_directions(origin = c(10.99, 45.44), 
                             destination = c(21.3, 42.00),
                           output = 'sf',
                       profile = "driving")

route_dir2 <- mb_directions(origin = start[1,], 
                             destination = end[1,],
                           output = 'sf',
                       profile = "cycling")

route_dir3 <- mb_directions(origin = start[1,], 
                             destination = end[1,],
                           output = 'sf',
                       profile = "walking")
route_dir <- rbind(route_dir1, route_dir2, route_dir3) 


```
```{r}

mapbox_map <- leaflet() %>%
  addMapboxTiles(style_id = "streets-v11",
                 username = "mapbox") 
mapbox_map %>%
  addPolylines(data = route_dir) 
```

### Savaria birthplace example
```{r}
## Automate for a given startplace
startplace <- "Savaria" 

data <-  EDHg_origo %>% 
  filter(origo_clean == startplace)

route_dr_final <- NULL
route_cy_final <-  NULL
route_w_final <- NULL

for (i in 1:nrow(data)){
  start <- data %>% 
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
 end <-  EDHg_findspot %>% 
   filter(origo_clean == startplace) %>%
   st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

route_dr_final

#mapbox_map %>%
#  addPolylines(data = route_dr_final)  # travel from Verona

route_dr_final <- read_rds("../data/drivefromSavaria.rds")
mapview(route_dr_final, zcol = "duration")

```
### Verona birthplace example
```{r}
## Automate for a given startplace
startplace <- "Verona" 

data <-  EDHg_origo %>% 
  filter(origo_clean == startplace)

route_dr_final <- NULL
route_cy_final <-  NULL
route_w_final <- NULL

for (i in 1:nrow(data)){
  start <- data %>% 
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
 end <-  EDHg_findspot %>% 
   filter(origo_clean == startplace) %>%
   st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

route_dr_final

mapbox_map %>%
  addPolylines(data = route_dr_final)  # travel from Verona

mapview(route_dr_final, zcol = "duration")
```


### Roma birthplace example
```{r}
## Automate for a given startplace
startplace <- "Roma" 

data <-  EDHg_origo %>% 
  filter(origo_clean == startplace)

route_dr_final <- NULL
route_cy_final <-  NULL
route_w_final <- NULL

for (i in 1:nrow(data)){
  start <- data %>% 
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
 end <-  EDHg_findspot %>% 
   filter(origo_clean == startplace) %>%
   st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

route_dr_final

mapbox_map %>%
  addPolylines(data = route_dr_final)  # travel from Verona

mapview(route_dr_final, zcol = "duration")
```


### Full Birth -Death Analysis

Let's see how many total unique deathplaces these birthplaces lead to:
```{r}
# Unique origins

# Create a sorted table of unique origins with unique findspots. Selection of findspot can be done many ways from ancient to modern findspot to latitude and longitude. I choose the largest result (531), which is produced by using longitude

origins_sorted <- EDHg_origo %>% 
  select(origo_clean, geometry, findspot_ancient_clean, findspot_modern_clean, latitude, longitude) %>%
  group_by(origo_clean) %>% 
  distinct(geometry, longitude, latitude, findspot_modern_clean) %>% 
  arrange(origo_clean) 

origin_count <- origins_sorted %>% 
  st_drop_geometry() %>% 
  group_by(origo_clean) %>% 
  summarize(cnt = n())  
  mutate(cound = cnt) 

  
origins_sorted <-   origins_sorted %>%
  left_join(origin_count, by = "origo_clean")



# Create and spatialized sorted destinations

destinations_sorted <- origins_sorted %>% 
  st_drop_geometry() %>% 
  st_as_sf(coords = c("longitude","latitude"), crs = 4326)

dest_count <- destinations_sorted %>% 
  st_drop_geometry() %>% 
  group_by(findspot_modern_clean) %>% 
  summarize(cnt = n()) 

destinations_sorted <- destinations_sorted %>% 
  left_join(dest_count, by= "findspot_modern_clean")

```
There are some 474 unique modern (452 ancient) death place names and 531 unique death coordinates for 187 origins.

### Sanity checks
```{r}
# Visual
# https://github.com/r-spatial/leafpop
library(leaflet)
leaflet() %>% 
  addTiles() %>% 
  addCircles(data = destinations_sorted$geometry, col = "black", 
             popup = paste0) %>% 
  addCircles(data = origins_sorted$geometry, col = "red")


mapview(origins_sorted) + mapview(destinations_sorted, cex = 1)

# doublecheck findspot alignment
destinations_sorted[,2] == origins_sorted[,3]
st_crs(destinations_sorted)==st_crs(origins_sorted)

```


```{r drive-from-origin, eval = FALSE}
library(mapboxapi)

route_dr_final <- NULL

for (i in 1:nrow(origins_sorted)){
  start <- origins_sorted %>% 
   # filter(grepl("^B", origo_clean)) %>% 
   # slice(155:160) %>%  #does not work in sf
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
   end <-  destinations_sorted %>%
#         filter(grepl("^B", origo_clean)) %>% 
   #slice(155:160) %>% 
     st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

# first result reached 155 features out of the 530

# save the resulting route!!!
saveRDS(route_dr_final, "../data/drivefrom155firstorigins.rds")
```
This should work, but the mapboxAPI does not like crossing the Gibraltar, so it's erroring out there.

### 150 first routes with all birthplaces, quantified by number of people
```{r}

route_dr_final <- readRDS("../data/drivefrom155firstorigins.rds")

mapview(regions, alpha = 0.01) + mapview(route_dr_final, alpha = 0.5, zcol = "distance") + mapview(origins_sorted, cex = "cnt", alpha = 0.1, zcol = "cnt")
```
### 150 first routes with all destinations, quantified by number of dedications found there
```{r}
mapview(route_dr_final, alpha = 0.5, zcol = "distance") + mapview(destinations_sorted, cex = "cnt", alpha = 0.1)
```

# Birth and Death place statistics


### Show numbers by region
```{r}
regions <- read_sf("../data/pleiades_regions.geojson")
sort(regions$name)
plot(regions$geometry)
```


```{r}
## Deathplace stats
EDHg_origo %>% 
  select( province_label_clean,findspot_ancient_clean, origo_clean) %>% 
  group_by(province_label_clean, findspot_ancient_clean) %>% 
  tally()
  
```

```{r}
## Birthplace stats
EDH_origo %>% 
  select( province_label_clean,findspot_ancient_clean, origo_clean) %>% 
  group_by(province_label_clean, origo_clean) %>% 
  tally()
  
```

# Gender

## What is the gender ratio of people on inscriptions? (male, female, NA)
```{r}
EDH_people %>% 
  count(gender, sort = TRUE) %>% 
  mutate(ratio = round(n/(sum(n)/100),2))
```

# Status

## What are the names of unique values in the 'status' attribute?
```{r}
EDH_people$status %>% 
  unique()
```


## What is the ratio of different statuses, e.g. slave vs freedman

```{r}
str_split_fixed(EDH_people$status, ";", n=3) %>% 
  as.data.frame() -> status

status %>% 
  cbind(combined = c(status$V1,status$V2,status$V3)) %>% 
  filter(combined != "") %>% 
  mutate(combined_clean = str_replace_all(string = combined, pattern = "\\?", replacement = "")) %>% 
  mutate(combined_clean = str_replace_all(string = combined_clean, pattern = "^ ", replacement = "")) %>% 
  count(combined_clean, sort=TRUE) -> status_counts

status_counts 
```

```{r}
status_counts %>% 
  mutate(combined_clean = reorder(combined_clean, n)) %>% 
  ggplot(aes(y=combined_clean, x=n, fill=combined_clean)) +
  geom_bar(width=0.8, stat="identity") +
  coord_cartesian(xlim=c(0,10000)) +
  labs(x = "Number of instances", y = "Status category", title = "Overview of status references in the EDH dataset", subtitle = ggtitle(paste("n =", nrow(EDH_tibble), "inscriptions"))) +
  geom_label(aes(label= n)) +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none")

#ggsave("../figures/Status_overview.jpg", width = 12, height = 8) 
#ggsave("../figures/Status_overview.png", width = 12, height = 8) 


```
log version
```{r}
status_counts %>% 
  mutate(log=round(log10(n),1)) %>% 
  mutate(combined_clean = reorder(combined_clean, log)) %>% 
  ggplot(aes(y=combined_clean, x=log, fill=combined_clean)) +
  geom_bar(width=0.8, stat="identity") +
  coord_cartesian(xlim=c(0,5)) +
  labs(x = "Number of instances (log10)", y = "Status category", title = "Status references in the EDH dataset", subtitle = ggtitle(paste("n =", nrow(EDH_people), "people in inscriptions"))) +
  geom_label(aes(label= n)) +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none")

ggsave("../figures/Status_overviewlog.png", width = 8, height = 6) 

```

# Age

## How many inscriptions have ‘Age’ category?

```{r}
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: years`) | !is.na(EDH_people$`age: months`) | !is.na(EDH_people$`age: days`) |!is.na(EDH_people$`age: hours`))
```


## What are the unique values for years
```{r}
unique(EDH_people$`age: years`)
```

## How many people have their age stated in years
```{r}
sum(!is.na(EDH_people$`age: years`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: years`))
```

## How many people have their age stated in months
```{r}
sum(!is.na(EDH_people$`age: months`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: months`))
```

## How many people have their age stated in days
```{r}
sum(!is.na(EDH_people$`age: days`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: days`))
```

## How many people have their age stated in hours
```{r}
sum(!is.na(EDH_people$`age: hours`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: hours`))
```


## What is the average age of people (years, months, days)

Not ideal method as it skips a lot of textual descriptions
```{r}
summary(as.numeric(EDH_people$`age: years`))
summary(as.numeric(EDH_people$`age: months`))
summary(as.numeric(EDH_people$`age: days`))
summary(as.numeric(EDH_people$`age: hours`))
```

Better method using regular expressions to detect years and converting them as numeric
```{r}
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>% 
  mutate(age_years = as.numeric(str_extract(EDH_people$'age: years', pattern = "[:digit:]+"))) %>% 
  mutate(age_months = as.numeric(str_extract(EDH_people$'age: months', pattern = "[:digit:]+"))) %>%
  mutate(age_days = as.numeric(str_extract(EDH_people$'age: days', pattern = "[:digit:]+"))) %>%
  mutate(age_hours = as.numeric(str_extract(EDH_people$'age: hours', pattern = "[:digit:]+"))) -> ages
```

```{r}
summary(ages$age_years)
summary(ages$age_months)
summary(ages$age_days)
summary(ages$age_hours)
```

## Combining all ages (years, months, days, hours) into one column

```{r}

ages <- ages %>% 
  mutate(months_to_years = age_months / 12) %>% 
  mutate(days_to_years = age_days / 365) %>% 
  mutate(hours_to_years = age_hours / (24*365))


ages <- ages %>%
  replace_na(list(months_to_years = 0, days_to_years = 0, hours_to_years = 0)) %>% 
  mutate(total_age = age_years + months_to_years + days_to_years + hours_to_years) %>% 
  dplyr::select(-ends_with("to_years"))

```


## Combine the total age with the rest of the dataset

```{r}

EDH_age<- EDH_people %>% 
  mutate(age_years = as.numeric(str_extract(EDH_people$'age: years', pattern = "[:digit:]+"))) %>% 
  mutate(age_months = as.numeric(str_extract(EDH_people$'age: months', pattern = "[:digit:]+"))) %>%
  mutate(age_days = as.numeric(str_extract(EDH_people$'age: days', pattern = "[:digit:]+"))) %>%
  mutate(age_hours = as.numeric(str_extract(EDH_people$'age: hours', pattern = "[:digit:]+"))) %>% 
  mutate(months_to_years = age_months / 12) %>% 
  mutate(days_to_years = age_days / 365) %>% 
  mutate(hours_to_years = age_hours / (24*365)) %>% 
  replace_na(list(months_to_years = 0, days_to_years = 0, hours_to_years = 0)) %>% 
  mutate(total_age = age_years + months_to_years + days_to_years + hours_to_years) %>% 
  dplyr::select(-ends_with("to_years")) 

```

## Summary of age in years

```{r}
summary(EDH_age$total_age)
```

### How many percent of people state their age on inscriptions
```{r}
length(na.omit(EDH_age$total_age))/(nrow(EDH_age)/100)
```




# Occupation
## What are the names of unique values in the 'occupation' attribute?
```{r}
EDH_people %>% 
  dplyr::filter(occupation == "data available") %>% 
  select()
```
Unfortunately, ant other details about the occupation are not provided.


# Special focus - Funerary inscriptions

```{r}
#merging of age dataset with other attributes from tibble

EDH_fun_age <- left_join(EDH_tibble, EDH_age, by = c("id" = "id"))

```



## Age

```{r}
EDH_fun %>% 
  filter(type_of_inscription_clean == "epitaph") -> epitaph
```

How many percent of people on funerary inscriptions state their age on inscriptions

```{r}
length(na.omit(epitaph$total_age))/(nrow(epitaph)/100)
```
### What is the age of people on funerary inscriptions by province
```{r, fig.height=8}
epitaph %>% 
  dplyr::select(total_age, province_label_clean) %>% 
  count(total_age, province_label_clean, sort=TRUE) %>% 
  ggplot(aes(x=total_age, y= fct_rev(province_label_clean))) + geom_point(alpha=0.5, color="darkblue") +
  theme_minimal()

ggsave("../figures/Age_years_provinces.png", width = 8, height = 8) 
```

I would like to see the inscription claiming 200 years of age. A typo? An ambitious guess?

### What is the average age of people on funerary inscriptions by province

```{r}
#install.packages("psych")
library(psych)

psych::describeBy(epitaph$total_age, group = epitaph$province_label_clean, mat = TRUE, digits = 2) -> age_provinces
head(age_provinces)
```

### Average age by provinces (All inscriptions)
```{r, fig.height=12}
age_provinces %>% 
  filter(n>0) %>% 
  mutate(group1 = reorder(group1, mean)) %>%  
  ggplot(aes(y=group1, x=mean)) +
  geom_col(color="white", fill="blue", width=0.8, stat="identity") +
  #coord_cartesian(xlim=c(0,80)) +
  theme_minimal() +
  theme(text = element_text(size=16)) +
  labs(y="Roman province", x="Years", title= "Average age of people on inscriptions in the EDH database by province", subtitle = "n= 7993 people")+ 
  #geom_label(aes(label= mean)) +
  geom_label(aes(label = mean), colour = "black", fontface = "bold", hjust = -0.1) 
  
ggsave("../figures/Age_average_years_provinces.png", width = 12, height = 12) 
```

How do you know it is 7993 records?

### ### Average age by provinces, with more than 100 inscriptions containing age per province
```{r, fig.height=12}
age_provinces %>% 
  filter(n>100) %>% 
  mutate(group1 = reorder(group1, mean)) %>%  
  ggplot(aes(y=group1, x=mean)) +
  geom_col(color="white", fill="blue", width=0.8, stat="identity") +
  #coord_cartesian(xlim=c(0,80)) +
  theme_minimal() +
  theme(text = element_text(size=16)) +
  labs(y="Roman province ", x="Years", title= "Average age of people on inscriptions in the EDH database by province with more than 100 inscriptions stating age", subtitle = "n= 7993 people")+ 
  #geom_label(aes(label= mean)) +
  geom_label(aes(label = mean), colour = "black", fontface = "bold", hjust = -0.1)
  
ggsave("../figures/Age_average_years_provinces_100plus_inscr.png", width = 12, height = 12) 
```


### Inscriptions with age by provinces
```{r, fig.height=12}
age_provinces %>% 
  filter(n>0) %>% 
  mutate(group1 = reorder(group1, n)) %>%  
  ggplot(aes(y=group1, x=n)) +
  geom_col(color="white", fill="purple", width=0.8, stat="identity") +
  #coord_cartesian(xlim=c(0,80)) +
  theme_minimal() +
  theme(text = element_text(size=16)) +
  labs(y="Roman province", x="n", title= "Instances of age information in the EDH database by province", subtitle = "n= 7993 people")+ 
  #geom_text(aes(label= n),hjust = -0.4) +
  geom_label(aes(label = n), colour = "black", fontface = "bold", hjust = -0.4) 

ggsave("../figures/Age_info_provinces.png", width = 12, height = 12) 
```

### Inscriptions by age groups

```{r}
EDH_age<- EDH_age %>%
  mutate(agegroup = case_when(total_age < 3 ~  "0-2.99",
                              total_age < 15 ~ "3-14.99",
                              total_age < 30 ~ "15-29.99",
                              total_age < 40 ~ "30-39.99",
                              total_age < 60 ~ "40-59.99",
                              total_age > 60 ~ "over 60"))

EDH_age$agegroup <- factor(EDH_age$agegroup, levels = c("0-2.99", "3-14.99","15-29.99", "30-39.99", "40-59.99","over 60"))  
```

# test works
```{r}
summary(EDH_age$total_age)
summary(EDH_age$agegroup)
```


```{r}
EDH_age %>% 
  filter(agegroup != "NA") %>%
  #count(agegroup, sort = TRUE) %>%
  #mutate(agegroup_sorted = reorder(agegroup, n)) %>% 
  ggplot() +
  geom_bar(mapping = aes(x = agegroup, fill = agegroup))+
  labs(x = "Age group (years)", y = "Number of individuals", title = "Representation of age groups on funerary inscriptions (EDH dataset)", subtitle = ggtitle(paste("n =", nrow(filter(EDH_age, agegroup != "NA")), "inscriptions")))+
  theme_minimal()
  #+ geom_label(aes(label = agegroup), colour = "black", fontface = "bold", hjust = -0.4) +


  
ggsave("../figures/Age_groups_epitaphs.png", width = 12, height = 8) 
```
### Children younger than 10

```{r}
EDH_fun<- EDH_fun %>% 
  mutate(age10 = ifelse(total_age < 10, "under10", "over10"))
```

#### Province
```{r, fig.height=14, fig.width=10}
EDH_fun %>% 
  count(age10, province_label_clean) %>% 
  ggplot(aes(fill=age10, y=province_label_clean, x=n)) +
  geom_bar(position="fill", stat="identity") +
  theme_minimal() +
  #theme(text = element_text(size=16)) +
  labs(y="Roman province", x="n", title= "Ratio of age children under 10 years on inscriptions per province") 
  #geom_text(aes(label= n),hjust = -0.4) 
  #geom_label(aes(label = n), colour = "black", fontface = "bold", hjust = -0.4) 

```

```{r}
EDH_age10<- EDH_fun %>% 
  count(age10, province_label_clean, sort=F) %>% 
  spread(key=age10, value=n) 

EDH_under10<- EDH_age10 %>% 
  mutate(total = rowSums(EDH_age10[2:4], na.rm=TRUE)) %>% 
  mutate(under10_ratio = under10 / (total/100)) %>% 
  mutate(over10_ratio = over10 / (total/100)) %>% 
  mutate(age_stated = (over10+under10) / (total/100))


EDH_under10 
```
```{r, fig.height=14, fig.width=10}
EDH_under10 %>%
  dplyr::select(province_label_clean, over10_ratio) %>% 
  #sort(over10_ratio, decreasing = TRUE, na.last = TRUE) %>% 
  ggplot(aes(y=province_label_clean, x=over10_ratio)) +
  geom_bar(stat="identity", position = "dodge") +
  theme_minimal() +
  #theme(text = element_text(size=16)) +
  labs(y="Roman province", x="%", title= "Ratio of children under 10 years on inscriptions per province") 
  #geom_text(aes(label= n),hjust = -0.4) 
  #geom_label(aes(label = n), colour = "black", fontface = "bold", hjust = -0.4)
```

### Rounding of age on inscriptions
```{r}
EDH_fun %>% 
  dplyr::select(total_age) %>% 
  filter(total_age == str_subset(total_age, "5$|0$")) -> rounded_age


all_ages <- as.data.frame(na.omit(EDH_fun$total_age))
nrow(rounded_age)/(nrow(all_ages)/100)
```

```{r}
rounded_age %>% 
  count(total_age)
```
### Non-rounded ages

```{r, fig.width=10}
all_ages %>% 
  count(`na.omit(EDH_fun$total_age)`) %>% 
  mutate(total_age =`na.omit(EDH_fun$total_age)`) %>% 
  ggplot(aes(x=total_age, y =n, colour=-n)) +
  geom_point(alpha=0.5) +
  geom_smooth() +
  geom_vline(xintercept = 10, linetype="dotted", 
               color = "green", size=0.5) +
  geom_vline(xintercept = 30, linetype="dotted", 
                color = "blue", size=0.5) +
  geom_vline(xintercept = 50, linetype="dotted", 
                color = "red", size=0.5) +
  geom_vline(xintercept = 70, linetype="dotted", 
                color = "brown", size=0.5)
  
```
### Population pyramid in funerary inscriptions


Adapted from https://klein.uk/teaching/viz/datavis-pyramids/

```{r}
EDH_fun %>% 
  dplyr::select(gender, total_age) %>% 
  na.omit(gender) %>% 
  na.omit(total_age)  %>% 
  mutate(gender = str_replace(gender, "M\\?", "male")) %>% 
  mutate(gender = str_replace(gender, "F\\?", "female")) -> population_age

## cut the age variable into age groups with 5-year intervals
population_age$age_cut <- cut(population_age$total_age, breaks = seq(0, 200, 5), right = FALSE) 
population_age$population <- 1 ## each sampled respondent represents 10 individuals

population_age <- population_age %>% 
  mutate(age = str_replace(age_cut, "\\[", "")) %>% 
  mutate(age = str_replace(age, "\\)", "")) %>% 
  mutate(age = str_replace(age, "\\,", " - ")) 

labels <- levels(population_age$age_cut) %>% 
  stringr::str_replace_all(.,
                                           c("\\[" = "",
                                             "\\)" = "",
                                             "\\," = " - "))
  
# Trying if setting age to factor will help with sorting
class(population_age$age)
population_age$age <- factor(population_age$age, levels=c(labels))

# As a back up: create a new column from desired age intervals that lists the group number to be used for sorting
population_age$order <- findInterval(population_age$total_age, c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100, 500))


sort(unique(population_age$order))
head(population_age)
population_age %>% 
  filter(order == 4)

## aggregate the data by gender and age group
population_age <- aggregate(formula = population ~ gender + age + order, data = population_age, FUN = sum)

## sort data by first by gender, then by age groups using *order*
population_age <- with(population_age, population_age[order(order,gender),])

#labels
xabels<- c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29", "30-34", "35-39", "40-44", "45-49", "50-54", "55-59", "60-64", "65-69", "70-74", "75-79", "80-84", "85-89", "90-94", "95-99", "100+")
# labels_df <- as.data.frame(labels)
# breaks = seq(0, 160, 5)

# AS: the original is poorly annotated. None of the lines of code specified WHY it is run. 
# Errors or problematic parts not clearly marked

  

population_age <- population_age[,c("age","order", "gender","population")]

population_age$population <- ifelse(population_age$gender == "male", -1*population_age$population, population_age$population)

# It is incredible how the ggplot sort lexicographically despite the factor!!


population_age$orderedage <- reorder(population_age$age, sort(population_age$order)) #https://kohske.wordpress.com/2010/12/29/faq-how-to-order-the-factor-variables-in-ggplot2/


pyramid_age <- ggplot(population_age, aes(x = orderedage, y = population, fill = gender)) + 
  geom_bar(aes(order), data = subset(population_age, gender == "female"), stat = "identity") +
  geom_bar(aes(order), data = subset(population_age, gender == "male"), stat = "identity") + 
  #scale_y_continuous(labels = c("250", "0", "250")) + 
  xlab("age groups")+
  scale_x_discrete(labels = xabels)+  # Still does not show!! But no Error. jeez.
  coord_flip()
pyramid_age
```

# Adela Different and Working (for change) Alternative
```{r}
EDH_fun %>% 
  dplyr::select(gender, total_age) %>% 
  na.omit(gender) %>% 
  na.omit(total_age)  %>% 
  mutate(gender = str_replace(gender, "M\\?", "male")) %>% 
  mutate(gender = str_replace(gender, "F\\?", "female")) -> population_age


# The column plotted on x (and flipped) needs to be a factor, but the example above is not working, 
# so lets' cut and label data with data.table library
library(data.table)

agebreaks <- c(0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100, 500)
agelabels <- c("0-4","5-9","10-14","15-19","20-24","25-29","30-34",
               "35-39","40-44","45-49","50-54","55-59","60-64","65-69",
               "70-74","75-79","80-84","85-89","90-94", "95-99","100+")
## cut the age variable into age groups with 5-year intervals

setDT(population_age)[ , agegroups := cut(total_age, 
                                breaks = agebreaks, 
                                right = FALSE, 
                                labels = agelabels)]

head(population_age)

population_age$population <- 1 ## each sampled respondent represents 10 individuals

# aggregate the data by gender and age group
population_age <- aggregate(formula = population ~ gender + agegroups, data = population_age, FUN = sum)

## sort data by first by gender, then by age groups
population_age <- with(population_age, population_age[order(agegroups,gender),])


population_age <- population_age[,c("agegroups","gender","population")]

population_age$population <- ifelse(population_age$gender == "male", -1*population_age$population, population_age$population)

pyramid_age <- ggplot(population_age, aes(x = agegroups, y = population, fill = gender)) + 
  geom_bar(data = subset(population_age, gender == "female"), stat = "identity") +
  geom_bar(data = subset(population_age, gender == "male"), stat = "identity") + 
  theme_minimal() +
  #scale_y_continuous(labels = c("250", "0", "250")) + 
  coord_flip()
pyramid_age

ggsave("../figures/Age_pyramid.jpg", width = 8, height = 8)
```


### Average age by individual years 

Using not before and not after date separately.

```{r}
describeBy(epitaph$total_age, group = epitaph$not_before, mat = TRUE, digits = 2) -> age_not_before

describeBy(epitaph$total_age, group = epitaph$not_after, mat = TRUE, digits = 2) -> age_not_after
```

### When (which years) do people state their age on funerary inscriptions

```{r}
age_not_bf_plot<- age_not_before %>% 
  ggplot(aes(x=group1, y=n)) +
  geom_point() +
  geom_vline(xintercept = 1, linetype="dotted", 
                color = "green", size=0.5) +
  geom_vline(xintercept = 100, linetype="dotted", 
                color = "blue", size=0.5) +
  geom_vline(xintercept = 200, linetype="dotted", 
                color = "red", size=0.5)
```


```{r}
age_not_aft_plot<- age_not_after %>% 
  ggplot(aes(x=group1, y=n)) +
  geom_point() +
  geom_vline(xintercept = 1, linetype="dotted", 
                color = "green", size=0.5) +
  geom_vline(xintercept = 100, linetype="dotted", 
                color = "blue", size=0.5) +
  geom_vline(xintercept = 200, linetype="dotted", 
                color = "red", size=0.5)
```
Commentary: People state their age in the second century the most!

### What is the average age of people on inscriptions in time
```{r}
age_not_before %>% 
  filter(!is.na(mean)) %>% 
  ggplot(aes(x=as.numeric(group1), y=as.numeric(mean))) +
  geom_point() +
  geom_smooth() +
  geom_vline(xintercept = 0, linetype="dotted", 
               color = "green", size=0.5) +
  geom_vline(xintercept = 100, linetype="dotted", 
                color = "blue", size=0.5) +
  geom_vline(xintercept = 200, linetype="dotted", 
                color = "red", size=0.5) +
  geom_vline(xintercept = 300, linetype="dotted", 
                color = "brown", size=0.5)



```


```{r}
age_not_after %>% 
  filter(!is.na(mean)) %>% 
  ggplot(aes(x=as.numeric(group1), y=as.numeric(mean))) +
  geom_point() +
  geom_smooth() +
  geom_vline(xintercept = 0, linetype="dotted", 
               color = "green", size=0.5) +
  geom_vline(xintercept = 100, linetype="dotted", 
                color = "blue", size=0.5) +
  geom_vline(xintercept = 200, linetype="dotted", 
                color = "red", size=0.5) +
  geom_vline(xintercept = 300, linetype="dotted", 
                color = "brown", size=0.5)

```


### One-offs

