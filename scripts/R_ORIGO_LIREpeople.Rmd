---
title: "Origo"
author: "Adela"
date: "2023-01-09"
output: html_document
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(mapview)
library(leaflet)
```

## Testing LIST 0.6 and LIRE 2.3
Here I test to extract people out of our aggregate datasets LIST nad LIRE respectively
```{r LIST}
LIST <- st_read_parquet("../data/large_data/LIST_v0-6.parquet")

# Check for the extistence of people column in LIST 
colnames(LIST)
LIST$people[1:2]
which(is.na(LIST$people)) # some 33555 inscriptions do not have a person associated 

# Check you have loaded origo parquet
unique(origo$hd_nr)

# Extract non-missing people from the origo subset
people_ls_unnested <- LIST %>% 
  dplyr::select(LIST.ID, EDH.ID, people) %>% 
  filter(EDH.ID %in% unique(origo$hd_nr)) %>% 
  unpack(people)  %>% 
  unnest_wider(people, simplify = TRUE) %>% 
  unnest_longer(c(person_id,name, cognomen, nomen, supernomen, gender, praenomen, `age: years`, `age: months`, `age: days`, `age: hours`, status, occupation, tribus, origo)) %>% 
  # selecting only inscriptions that have people
  filter(!is.na(person_id))

# See who has "origo" - 2288 individuals.
people_ls_unnested %>% 
  filter(!is.na(origo))

# Add column so join with origo is possible
people_ls_unnested <- people_ls_unnested %>% 
 # filter(!is.na(origo))%>% 
  mutate(id = paste0(EDH.ID,"/",person_id))


# Extract non-missing people from LIRE
# list_people_unnest <- LIST %>% 
#   dplyr::select(LIST.ID, EDH.ID, people) %>% 
#   filter(!is.na(people)) %>% 
#   unpack(people)  %>% 
#   unnest_wider(people, simplify = TRUE) %>% 
#   unnest_longer(c(person_id,name, cognomen, nomen, supernomen, gender, praenomen, `age: years`, `age: months`, `age: days`, `age: hours`, status, occupation, tribus, origo)) %>% 
#   # selecting only inscriptions that have people
#   filter(!is.na(person_id))

```

## LIRE

```{r LIRE}
#LIRE <- st_read_parquet("../data/large_data/LIRE")

# Check for the existence of people column in LIRE 
colnames(LIRE)
LIRE$people[1:2]
length(which(is.na(LIRE$people))) # some 19829 LIRE inscriptions do not have a person associated 

# Check you have loaded origo parquet
unique(origo$hd_nr)

# Extract non-missing people from the origo subset
people_or_unnested <- LIRE %>% 
  dplyr::select(LIST.ID, EDH.ID, people) %>% 
  filter(EDH.ID %in% unique(origo$hd_nr)) %>% 
  unpack(people)  %>% 
  unnest_wider(people, simplify = TRUE) %>% 
  unnest_longer(c(person_id,name, cognomen, nomen, supernomen, gender, praenomen, `age: years`, `age: months`, `age: days`, `age: hours`, status, occupation, tribus, origo)) %>% 
  # selecting only inscriptions that have people
  filter(!is.na(person_id)) # 4562 people with 18 attributes


# See who has "origo" - 2263 LIRE individuals
people_or_unnested <- people_or_unnested %>% 
  filter(!is.na(origo)) %>% 
  mutate(id = paste0(EDH.ID,"/",person_id))

# at least 14 origo people are missing, which ones? Perhaps ones born outside of empire?

'%nin%' <- Negate('%in%')
origo %>% 
  filter(id%nin%people_or_unnested$id) %>% 
  st_set_crs(4326) %>% 
  mapview()

birthplace %>% 
  filter(id%nin%people_or_unnested$id) %>% 
  mapview()
```

The script below should be run in sequence to R_EXPLORING PEOPLE where the necessary data> EDH tibble are created and people unnested.
There is the origo and then lots of findspot data, e.g., findspot_ancient, findspot_modern, their cleaned versions and findspot_certainty, 

```{r EDH}
EDH_people <- readRDS("../data/large_data/edh_people21.rds")
head(EDH_people) # EDH_people comes from R_EXPLORING_PEOPLE script 
EDH_people %>% 
  select(matches("cognomen|findspot|origo|province|geo"))
colnames(LIST)

```
There is origo in the people attribute and additional 14 columns with spatial/geographic information in the enriched EDH attributes. Except for origo, they originate from the inscription itself, describing its provenance or context of discovery.


# Origo in EDH people
```{r}
EDH_people %>% 
  filter(!is.na(origo)) %>% #distinct(origo)
  count(origo, sort=TRUE)
```
# Birth to Death Distance Analysis

So this is tricky as the `origo` is an ancient placename that does not come with coordinates, can be ambiguous, poorly spelled and without a physical referent!
Also, out of 92427 people in the EDH inscriptions, only 2648 (2.8%) mention origo in their message
Out of these 2648 locations there are 673 unique geocoded placenames.

## Bring in json data from sciencedk geocoded by Vojtech in 2021 
in py_geocode_origo
The json output has 2648 rows just like there are people with origo in the EDH dataset, however only 676 unique origo ( presumed birthplace) locations have been successfully geocoded, adn three of those lack lat/long of the findspot (presumed deathplace)

```{r eval = FALSE}
# geoorigo <- jsonlite::fromJSON("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/EDH_origo_geo_2021-08-24.json")

# all 92427 people records with all attributes incl origo
geoorigo <- as_tibble(geoorigo)  
names(geoorigo)


# 2648 records of people with origo
has_origo_sm <- geoorigo %>%   
  select(matches("person_id|origo|long|lat|findspot|gender|status|province|country")) %>% 
  filter(origo != "NULL")

# 676 successfully geocoded origo_geo records 
EDH_origo <- has_origo_sm %>% 
  filter(origo_geo != "NULL")

```
Format of EDH_origo is annoying All the columns are lists which is annoying. Let's unlist all of them
```{r unlist}
unnest_all <- function(df) {
  list_columns <- df %>% keep(is.list) %>% names()
  
  if (length(list_columns) == 0) {
    return(df)
  }

  for (list_column in list_columns) {
    df <-
      df %>%
      unnest_wider(list_column, names_sep = "_")
  }
  unnest_all(df)
}

EDH_origo <- unnest_all(EDH_origo)
names(EDH_origo) <- gsub("_1","", names(EDH_origo))
EDH_origo

# Save the 
# saveRDS(EDH_origo, "../data/origo_df.rds") 
# EDH_origo <- read_rds("../data/origo_df.rds")
# EDH_origo
```

### Spatialize origo - Create Birth places

Eliminate missing coordinates
```{r}
EDH_origo[which(is.na(EDH_origo$longitude)),]  # points are missing lat/long, one legit, one Aquincum and one laggachen

EDH_origo <- EDH_origo %>% 
  filter(!is.na(longitude))
```

```{r spatialize}
library(sf)

EDHg_origo <- EDH_origo %>% 
  st_as_sf(coords = c("origo_geo_2", "origo_geo"), crs = 4326)

EDHg_findspot <- EDH_origo %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326)

#Save
# saveRDS(EDHg_origo, "../data/EDH_origo_sp.rds")
# saveRDS(EDHg_findspot, "../data/EDH_origo_findpot_sp.rds")
```

Let's now draw linestrings between the origin and final findspot, our proxies between the birth and death places of each of the 676 persons here.
We need a matrix of both sets of points

## Create Birth-Death place linestrings

We connect the origo (birthplace) column coordinates with findspot (deathplace) by great circles in geodetic space

```{r}
lines <- st_sfc(mapply(function(a,b){
  st_cast(st_union(a,b),"LINESTRING")}, 
  EDHg_origo$geometry, EDHg_findspot$geometry, SIMPLIFY=FALSE))

st_crs(lines) <- 4326

library(mapview)
mapview(lines)
```


## Calculate as-the-crow-flies distances
Let's calculate great circle distances and differentiate lines by length

```{r line-length}
# Convert lines to sf and calculate length
lines_sf <- st_as_sf(lines)
lines_sf$length <- st_length(lines)

# Convert to km - but beware it is still declared as m
lines_sf$length_km <- unclass(lines_sf$length/1000)

# See the length visualized
mapview(lines_sf, zcol = "length_km")
```
### Let's see the range of distances travelled
If we connect the birth and death places with great circle distances, ignoring roads and other barriers as well as sea travel. All distances are wrong in similar way. Yet, we can assume that dying 500km away from home is serious. So even if it is only 3% people, the distances are substantial and that may be why origo is  mentioned
If the Romans could fly as the crows, these would be their ranges.
```{r}
lines_sf$length_km %>% 
  hist( main = "Great Circle distances from birth region to death region", xlab = "km")
```
```{r}
sum(unclass(lines_sf$length_km)) / nrow(EDH_origo) #in kilometers not meters
```

## Walk around the Empire with MapBoxAPIe
Let's see which origins are most common. 
```{r}
EDH_origo %>% 
  group_by(origo_clean) %>% 
  tally() %>% arrange(desc(n))

```
The most frequent starting places are Remesiana (41), Ratiaria(32), Verona(28), Roma(27) and Savaria(25).

### A test minidataset
And if we were to reduce data to the top 5

```{r}
top5 <- EDH_origo %>% 
  group_by(origo_clean) %>% 
  tally() %>% arrange(desc(n)) %>% slice(1:5)
EDHg_origo %>% 
  filter(origo_clean %in% top5$origo_clean) %>% 
  select(origo_clean, findspot_modern) %>%
  group_by(origo_clean) %>% 
  distinct(findspot_modern) %>% 
  arrange(origo_clean)
```
Remesiana people all die/dedicate in Kostolac, but natives of Rome, Verona and Savaria go to many different places.

### Starting mapboxAPI and its directions module
```{r}
library(mapboxapi)

?mb_directions
startplace <- "Verona"

# a pair of coordinates is needed for the origin and destination
route_dir1 <- mb_directions(origin = c(10.99, 45.44), 
                             destination = c(21.3, 42.00),
                           output = 'sf',
                       profile = "driving")

route_dir2 <- mb_directions(origin = start[1,], 
                             destination = end[1,],
                           output = 'sf',
                       profile = "cycling")

route_dir3 <- mb_directions(origin = start[1,], 
                             destination = end[1,],
                           output = 'sf',
                       profile = "walking")
route_dir <- rbind(route_dir1, route_dir2, route_dir3) 


```
```{r}

mapbox_map <- leaflet() %>%
  addMapboxTiles(style_id = "streets-v11",
                 username = "mapbox") 
mapbox_map %>%
  addPolylines(data = route_dir) 
```

### Savaria birthplace example
```{r}
## Automate for a given startplace
startplace <- "Savaria" 

data <-  EDHg_origo %>% 
  filter(origo_clean == startplace)

route_dr_final <- NULL
route_cy_final <-  NULL
route_w_final <- NULL

for (i in 1:nrow(data)){
  start <- data %>% 
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
 end <-  EDHg_findspot %>% 
   filter(origo_clean == startplace) %>%
   st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

route_dr_final

#mapbox_map %>%
#  addPolylines(data = route_dr_final)  # travel from Verona

route_dr_final <- read_rds("../data/drivefromSavaria.rds")
mapview(route_dr_final, zcol = "duration")

```
### Verona birthplace example
```{r}
## Automate for a given startplace
startplace <- "Verona" 

data <-  EDHg_origo %>% 
  filter(origo_clean == startplace)

route_dr_final <- NULL
route_cy_final <-  NULL
route_w_final <- NULL

for (i in 1:nrow(data)){
  start <- data %>% 
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
 end <-  EDHg_findspot %>% 
   filter(origo_clean == startplace) %>%
   st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

route_dr_final

mapbox_map %>%
  addPolylines(data = route_dr_final)  # travel from Verona

mapview(route_dr_final, zcol = "duration")
```


### Roma birthplace example
```{r}
## Automate for a given startplace
startplace <- "Roma" 

data <-  EDHg_origo %>% 
  filter(origo_clean == startplace)

route_dr_final <- NULL
route_cy_final <-  NULL
route_w_final <- NULL

for (i in 1:nrow(data)){
  start <- data %>% 
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
 end <-  EDHg_findspot %>% 
   filter(origo_clean == startplace) %>%
   st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

route_dr_final

mapbox_map %>%
  addPolylines(data = route_dr_final)  # travel from Verona

mapview(route_dr_final, zcol = "duration")
```


### Full Birth -Death Analysis

Let's see how many total unique deathplaces these birthplaces lead to:
```{r}
# Unique origins

# Create a sorted table of unique origins with unique findspots. Selection of findspot can be done many ways from ancient to modern findspot to latitude and longitude. I choose the largest result (531), which is produced by using longitude

origins_sorted <- EDHg_origo %>% 
  select(origo_clean, geometry, findspot_ancient_clean, findspot_modern_clean, latitude, longitude) %>%
  group_by(origo_clean) %>% 
  distinct(geometry, longitude, latitude, findspot_modern_clean) %>% 
  arrange(origo_clean) 

origin_count <- origins_sorted %>% 
  st_drop_geometry() %>% 
  group_by(origo_clean) %>% 
  summarize(cnt = n())  
  mutate(cound = cnt) 

  
origins_sorted <-   origins_sorted %>%
  left_join(origin_count, by = "origo_clean")



# Create and spatialized sorted destinations

destinations_sorted <- origins_sorted %>% 
  st_drop_geometry() %>% 
  st_as_sf(coords = c("longitude","latitude"), crs = 4326)

dest_count <- destinations_sorted %>% 
  st_drop_geometry() %>% 
  group_by(findspot_modern_clean) %>% 
  summarize(cnt = n()) 

destinations_sorted <- destinations_sorted %>% 
  left_join(dest_count, by= "findspot_modern_clean")

```
There are some 474 unique modern (452 ancient) death place names and 531 unique death coordinates for 187 origins.

### Sanity checks
```{r}
# Visual
# https://github.com/r-spatial/leafpop
library(leaflet)
leaflet() %>% 
  addTiles() %>% 
  addCircles(data = destinations_sorted$geometry, col = "black", 
             popup = paste0) %>% 
  addCircles(data = origins_sorted$geometry, col = "red")


mapview(origins_sorted) + mapview(destinations_sorted, cex = 1)

# doublecheck findspot alignment
destinations_sorted[,2] == origins_sorted[,3]
st_crs(destinations_sorted)==st_crs(origins_sorted)

```


```{r drive-from-origin, eval = FALSE}
library(mapboxapi)

route_dr_final <- NULL

for (i in 1:nrow(origins_sorted)){
  start <- origins_sorted %>% 
   # filter(grepl("^B", origo_clean)) %>% 
   # slice(155:160) %>%  #does not work in sf
      st_coordinates()  #	We need an address or coordinate pair that   represents the destination of your requested route c(longitude, latitude)
   end <-  destinations_sorted %>%
#         filter(grepl("^B", origo_clean)) %>% 
   #slice(155:160) %>% 
     st_coordinates()
  route_drive <- mb_directions(origin = start[i,], 
                             destination = end[i,],
                       profile = "driving")
   # route_cycle <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "cycling")
   #  route_walk <- mb_directions(origin = start[i,], 
   #                           destination = end[i,],
   #                     profile = "walking")
route_dr_final <- rbind(route_dr_final, route_drive)
# route_cy_final <- rbind(route_cy_final, route_cycle)
# route_w_final <- rbind(route_w_final, route_walk)
}

# first result reached 155 features out of the 530

# save the resulting route!!!
saveRDS(route_dr_final, "../data/drivefrom155firstorigins.rds")
```
This should work, but the mapboxAPI does not like crossing the Gibraltar, so it's erroring out there.

### 150 first routes with all birthplaces, quantified by number of people
```{r}

route_dr_final <- readRDS("../data/drivefrom155firstorigins.rds")

mapview(regions, alpha = 0.01) + mapview(route_dr_final, alpha = 0.5, zcol = "distance") + mapview(origins_sorted, cex = "cnt", alpha = 0.1, zcol = "cnt")
```
### 150 first routes with all destinations, quantified by number of dedications found there
```{r}
mapview(route_dr_final, alpha = 0.5, zcol = "distance") + mapview(destinations_sorted, cex = "cnt", alpha = 0.1)
```

# Birth and Death place statistics


### Show numbers by region
```{r}
regions <- read_sf("../data/pleiades_regions.geojson")
sort(regions$name)
plot(regions$geometry)
```


```{r}
## Deathplace stats
EDHg_origo %>% 
  select( province_label_clean,findspot_ancient_clean, origo_clean) %>% 
  group_by(province_label_clean, findspot_ancient_clean) %>% 
  tally()
  
```

```{r}
## Birthplace stats
EDH_origo %>% 
  select( province_label_clean,findspot_ancient_clean, origo_clean) %>% 
  group_by(province_label_clean, origo_clean) %>% 
  tally()
  
```

# Gender

## What is the gender ratio of people on inscriptions? (male, female, NA)
```{r}
# 2648 EDH data
EDH_people %>% 
  count(gender, sort = TRUE) %>% 
  mutate(ratio = round(n/(sum(n)/100),2))

# 2277 origo data
origo %>% 
  st_drop_geometry() %>% 
  left_join(people_ls_unnested, by = "id") %>% 
  count(gender, sort = TRUE) %>% 
  mutate(ratio = round(n/(sum(n)/100),2))


people_or_unnested %>% 
  mutate(id = paste0(EDH.ID,"/",person_id)) %>% 
 # filter(!is.na(id)) %>% glimpse
  count(gender, sort = TRUE) %>% 
  mutate(ratio = round(n/(sum(n)/100),2))
```

## What kinds of inscription has origo (transfer to EDH PERSONS!) based on origo 2277
To explore other inscription-derived attributes of people with origin, we need to use a joined dataset of origo and EDH attributes

```{r}
# number of inscriptions that have origo (whether geocoded or not)
EDH_people %>% 
  filter(!is.na(origo)) %>% 
  group_by(id) %>% 
  tally()


origo %>%  #
  st_drop_geometry() %>% 
#left_join(people_ls_unnested, by = "id") %>% # join more people attributes
 left_join(LIST, by= c("hd_nr" = "EDH.ID")) %>% # join inscription attributes
  count(type_of_inscription_clean, sort=T) %>% 
  mutate(ratio = round(n/(sum(n)/100),1)) %>% 
  slice(1:5)

```
Visualisation in a piechart

```{r}
origo %>%  #
  st_drop_geometry() %>% 
  left_join(LIST, by= c("hd_nr" = "EDH.ID")) %>%  # was EDH_full
  count(type_of_inscription_clean, sort=T) %>% 
  mutate(ratio = round(n/(sum(n)/100),2)) %>% 
  slice(c(1:4,6:8)) %>%   # grab the first seven categories
  ggplot(aes(x = "", y = ratio, fill = type_of_inscription_clean)) +
  geom_bar(stat="identity", width=2, color = "white") +
  coord_polar("y", start=0.5)+
  labs(fill = paste0("Inscription type (n = 2277)"))+
  theme_void() # remove background, grid, numeric labels
```

Expressions of 'origo' feature mostly in epitaphs followed by honorific and votive inscriptions, lists and military diplomas. Epitaphs are personal, while most others can be also more public.


# Status

## What are the names of unique values in the 'status' attribute?
```{r}
EDH_people$status %>% 
  unique()
```
Look at how after 20 records or so there are more than one status, separated by ;? Let's split these up.

## What is the ratio of different statuses, e.g. slave vs freedman in EDH_people

```{r LIRE-people-status-calc}
# Who has declared status?
EDH_people %>% 
  filter(!is.na(status))  # 24,632 people have
length(which(!is.na(EDH_people$status)))
# SPlit the multiple statuses into separate columns
status <- EDH_people %>% 
  filter(!is.na(status)) %>% 
  pull(status) %>% 
  str_split_fixed(";", n=3) %>% 
  as.data.frame()

# Check what is in the new columns
unique(status$V2) # lots of different occupations
unique(status$V3) # military personnel

# count all the statuses
status %>% 
  cbind(combined = c(status$V1,status$V2,status$V3)) %>% 
  filter(combined != "") %>% 
  mutate(combined_clean = str_replace_all(string = combined, pattern = "\\?", replacement = "")) %>% 
  mutate(combined_clean = str_replace_all(string = combined_clean, pattern = "^ ", replacement = "")) %>% 
  count(combined_clean, sort=TRUE) -> status_counts

status_counts 

# Count only the first (highest) status
status_one <- status %>% 
  select(V1) %>% 
  mutate(V1 = str_replace_all(string = V1, pattern = "\\?", replacement = "")) %>% 
  group_by(V1) %>% 
  count(V1) %>% arrange(desc(n))
```
## Overview status LIRE ggplot
```{r ggplot-LIRE-status}
status_counts %>% 
  slice(1:8) %>% 
  mutate(combined_clean = reorder(combined_clean, n)) %>% 
  ggplot(aes(y=combined_clean, x=n, fill=combined_clean)) +
  geom_bar(width=0.8, stat="identity") +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 20))+
  #scale_fill_grey()+
  coord_cartesian(xlim=c(0,10000)) +
  labs(x = "Number of instances", 
       y = "", 
       title = "Status among LIRE people", subtitle = ggtitle(paste("n =", length(which(!is.na(EDH_people$status))), "status declarations"))) +
  geom_label(aes(label= n), fill = "white") +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none")

#ggsave("../figures/Status_LIREcol.tiff", width = 12, height = 8) 
#ggsave("../figures/Status_LIREbw.png", width = 12, height = 8) 
```
### log version LIRE
```{r}
LIRE_statuslog_clr <- status_counts %>% 
  slice(1:8) %>% 
  mutate(log=round(log10(n),1)) %>% 
  mutate(combined_clean = reorder(combined_clean, log)) %>% 
  ggplot(aes(y=combined_clean, x=log, fill=combined_clean)) +
  geom_bar(width=0.8, stat="identity") +
 # scale_fill_grey()+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 20))+
  coord_cartesian(xlim=c(0,4)) +
  labs(x = "Number of instances (log10)", 
       y = "", 
       title = "Status among LIRE people", 
       subtitle = ggtitle(paste("n =", length(which(!is.na(EDH_people$status))), "status declarations"))) +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none")+
  geom_label(aes(label= n), fill = "white") 

ggsave("../figures/Status_LIRElog_col.tiff", width = 8, height = 6) 

LIRE_statuslog <- status_counts %>% 
  slice(1:8) %>% 
  mutate(log=round(log10(n),1)) %>% 
  mutate(combined_clean = reorder(combined_clean, log)) %>% 
  ggplot(aes(y=combined_clean, x=log, fill=combined_clean)) +
  geom_bar(width=0.8, stat="identity") +
  scale_fill_grey()+
  scale_y_discrete(labels = function(x) str_wrap(x, width = 20))+
  coord_cartesian(xlim=c(0,4)) +
  labs(x = "Number of instances (log10)", 
       y = "", 
       title = "Status among LIRE people", 
       subtitle = ggtitle(paste("n =", length(which(!is.na(EDH_people$status))), "status declarations"))) +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none")+
  geom_label(aes(label= n), fill = "white")

ggsave("../figures/Status_LIRElog_bw.tiff", width = 8, height = 6) 
ggsave("../figures/Status_LIRElog_bw.png", width = 8, height = 6) 

```
##  Status in origo people (USE for origo paper)
```{r origo-people-status}
# Who has declared status in 2277 origo?
origo_people <- origo %>% 
  st_drop_geometry() %>% 
  left_join(people_ls_unnested, by = "id")

origo_people %>% # join more people attributes
  filter(!is.na(status))  # 1477 people have

# SPlit the multiple statuses into separate columns
status <- origo_people %>% 
  filter(!is.na(status)) %>% 
  pull(status) %>% 
  str_split_fixed(";", n=3) %>% 
  as.data.frame()

# Check what is in the new columns
unique(status$V2) # lots of different occupations
unique(status$V3) # military personnel

# count all the statuses
status %>% 
  cbind(combined = c(status$V1,status$V2,status$V3)) %>% 
  filter(combined != "") %>% 
  mutate(combined_clean = str_replace_all(string = combined, pattern = "\\?", replacement = "")) %>% 
  mutate(combined_clean = str_replace_all(string = combined_clean, pattern = "^ ", replacement = "")) %>% 
  count(combined_clean, sort=TRUE) -> status_counts

status_counts 

# Count only the first (highest) status
status_one <- status %>% 
  select(V1) %>% 
  mutate(status = str_replace_all(string = V1, pattern = "\\?", replacement = "")) %>% 
  group_by(status) %>% 
  count(status) %>% #, sort = TRUE) #%>% 
  arrange(n)
status_one
```

### ORIGO STATUS log version ggplot
```{r}
# with multiple statuses all collated 1277 soldiers, greyscale follows n
status_counts %>% 
  mutate(log=round(log10(n),1)) %>% 
  mutate(combined_clean = reorder(combined_clean, log)) %>% 
  ggplot(aes(y=combined_clean, x=log, fill=combined_clean)) +
  geom_bar(width=0.8, stat="identity") +
  scale_fill_grey()+
  coord_cartesian(xlim=c(0,3.5)) +
  labs(x = "Number of instances (log10)",
       y = "",
       title = "Status among people with origo",
    subtitle = ggtitle(paste("n =", nrow(status), "people"))) +
  geom_label(aes(label= n),colour = "black" ,fill = "white") +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none")

ggsave("../figures/Status_origo1277_col.png", width = 8, height = 6)

# single status per person (last, highest) 1264 soldiers, greysale follows alphabetically
origo_status_log <- status_one %>% 
  mutate(log =round(log10(n), 1)) %>% 
  mutate(status = factor(status)) %>% 
  #mutate(status = fct_reorder(status, n)) %>% 
  ggplot(aes(y = status, x =log, fill = status)) +
  geom_col(width=0.8, 
         #  fill = "grey",
           show.legend = FALSE) + #, stat = "identity"
  scale_y_discrete(limits = status_one$status,
                    labels = function(x) str_wrap(x, width = 20))+
  scale_fill_grey()+
  coord_cartesian(xlim=c(0,3.5)) +
  labs(x = "Number of instances (log10)", 
       y = "", 
       title = "Status among people with origo", 
       subtitle = ggtitle(paste("n =", nrow(status), "status declarations")))  +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none") +
  geom_label(aes(label= n),colour = "black" ,fill = "white")

# single status per person (last, highest) 1264 soldiers, full grey
origo_status_log <- status_one %>% 
  mutate(log =round(log10(n), 1)) %>% 
  mutate(status = factor(status)) %>% 
  #mutate(status = fct_reorder(status, n)) %>% 
  ggplot(aes(y = status, x =log)) +
  geom_col(width=0.8, 
           #color= "black",
           fill = "grey",
           show.legend = FALSE) + #, stat = "identity"
  scale_y_discrete(limits = status_one$status,
                    labels = function(x) str_wrap(x, width = 20))+
  #scale_fill_grey()+
  coord_cartesian(xlim=c(0,3.5)) +
  labs(x = "Number of instances (log10)", 
       y = "", 
       title = "Status among people with origo", 
       subtitle = ggtitle(paste("n =", nrow(status), "status declarations")))  +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none") +
  geom_label(aes(label= n),colour = "black" ,fill = "white")

ggsave("../figures/Status_origo1264_bw.png", width = 8, height = 6) 

origo_status_clrlog <- status_one %>% 
  mutate(log =round(log10(n), 1)) %>% 
  mutate(status = factor(status)) %>% 
  #mutate(status = fct_reorder(status, n)) %>% 
  ggplot(aes(y = status, x =log,fill = status)) +
  geom_col(width=0.8, 
           #fill = status,
           show.legend = FALSE) + #, stat = "identity"
  scale_y_discrete(limits = status_one$status,
                    labels = function(x) str_wrap(x, width = 20))+
  #scale_fill_grey()+
  coord_cartesian(xlim=c(0,3.5)) +
  labs(x = "Number of instances (log10)", 
       y = "", 
       title = "Status among people with origo", 
       subtitle = ggtitle(paste("n =", nrow(status), "status declarations")))  +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none") +
  geom_label(aes(label= n),colour = "black" ,fill = "white")


```

### COmbine  lire with origo grids

```{r}
# COmbine BW versions
library(gridExtra)
plist <- list(origo_status_log, LIRE_statuslog)
grid.arrange(grobs = plist, ncol = 2)
ggsave("../figures/Status_combo_bw.png", arrangeGrob(grobs = plist, ncol=2), width = 16, height = 6) 


# Combine COLOR versions
library(gridExtra)
plist <- list(origo_status_clrlog, LIRE_statuslog_clr)
grid.arrange(grobs = plist, ncol = 2)
ggsave("../figures/Status_combo_col.png", arrangeGrob(grobs = plist, ncol=2), width = 16, height = 6) 

```

# Age

## How many inscriptions have ‘Age’ category?

```{r}
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: years`) | !is.na(EDH_people$`age: months`) | !is.na(EDH_people$`age: days`) |!is.na(EDH_people$`age: hours`))
```


## What are the unique values for years
```{r}
unique(EDH_people$`age: years`)
```

## How many people have their age stated in years
```{r}
sum(!is.na(EDH_people$`age: years`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: years`))
```

## How many people have their age stated in months
```{r}
sum(!is.na(EDH_people$`age: months`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: months`))
```

## How many people have their age stated in days
```{r}
sum(!is.na(EDH_people$`age: days`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: days`))
```

## How many people have their age stated in hours
```{r}
sum(!is.na(EDH_people$`age: hours`))
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>%
  filter(!is.na(EDH_people$`age: hours`))
```


## What is the average age of people (years, months, days)

Not ideal method as it skips a lot of textual descriptions
```{r}
summary(as.numeric(EDH_people$`age: years`))
summary(as.numeric(EDH_people$`age: months`))
summary(as.numeric(EDH_people$`age: days`))
summary(as.numeric(EDH_people$`age: hours`))
```

Better method using regular expressions to detect years and converting them as numeric
```{r}
EDH_people %>% 
  dplyr::select('age: days', 'age: months', 'age: hours', 'age: years') %>% 
  mutate(age_years = as.numeric(str_extract(EDH_people$'age: years', pattern = "[:digit:]+"))) %>% 
  mutate(age_months = as.numeric(str_extract(EDH_people$'age: months', pattern = "[:digit:]+"))) %>%
  mutate(age_days = as.numeric(str_extract(EDH_people$'age: days', pattern = "[:digit:]+"))) %>%
  mutate(age_hours = as.numeric(str_extract(EDH_people$'age: hours', pattern = "[:digit:]+"))) -> ages
```

```{r}
summary(ages$age_years)
summary(ages$age_months)
summary(ages$age_days)
summary(ages$age_hours)
```

## Combining all ages (years, months, days, hours) into one column

```{r}

ages <- ages %>% 
  mutate(months_to_years = age_months / 12) %>% 
  mutate(days_to_years = age_days / 365) %>% 
  mutate(hours_to_years = age_hours / (24*365))


ages <- ages %>%
  replace_na(list(months_to_years = 0, days_to_years = 0, hours_to_years = 0)) %>% 
  mutate(total_age = age_years + months_to_years + days_to_years + hours_to_years) %>% 
  dplyr::select(-ends_with("to_years"))

```


## Combine the total age with the rest of the dataset

```{r}

EDH_age<- EDH_people %>% 
  mutate(age_years = as.numeric(str_extract(EDH_people$'age: years', pattern = "[:digit:]+"))) %>% 
  mutate(age_months = as.numeric(str_extract(EDH_people$'age: months', pattern = "[:digit:]+"))) %>%
  mutate(age_days = as.numeric(str_extract(EDH_people$'age: days', pattern = "[:digit:]+"))) %>%
  mutate(age_hours = as.numeric(str_extract(EDH_people$'age: hours', pattern = "[:digit:]+"))) %>% 
  mutate(months_to_years = age_months / 12) %>% 
  mutate(days_to_years = age_days / 365) %>% 
  mutate(hours_to_years = age_hours / (24*365)) %>% 
  replace_na(list(months_to_years = 0, days_to_years = 0, hours_to_years = 0)) %>% 
  mutate(total_age = age_years + months_to_years + days_to_years + hours_to_years) %>% 
  dplyr::select(-ends_with("to_years")) 

```

## Summary of age in years

```{r}
summary(EDH_age$total_age)
```

### How many percent of people state their age on inscriptions
```{r}
length(na.omit(EDH_age$total_age))/(nrow(EDH_age)/100)
```


## Totally random - Augustales

```{r}
# Explore Augustales: do they have occupation, gender and where does this self-identification occur?
EDH_people %>% 
  filter(grepl("Augustales", status, ignore.case = T)) %>% 
  # filter(!is.na(occupation))  # 14 out of 651 have occupation data
  # count(gender) # 2 women and 475 men in 651 records
  left_join(LIST, by = c("id" = "EDH.ID")) %>% 
  count(type_of_inscription_clean) %>% 
  arrange(desc(n)) # epitaphs and votives are matched 

# What is the distribution of Augustales findspots by time
EDH_people %>% 
  filter(grepl("Augustales", status, ignore.case = T)) %>% 
  left_join(LIST, by = c("id" = "EDH.ID")) %>% 
  filter(!is.na(Longitude)) %>% 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>% 
  mapview(zcol = "not_before") 
  
# What is the distribution of Augustales findspots by time
EDH_people %>% 
  #filter(grepl("Augustales", status, ignore.case = T)) %>% 
   filter(grepl("Eros", cognomen, ignore.case=T)) %>% 
  left_join(LIST, by = c("id" = "EDH.ID")) %>% 
  filter(!is.na(Longitude)) %>% 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>% 
  mapview(zcol = "type_of_inscription_clean")

```

Augustales appear only in Europe - none in Africa or Levant. Many votives and dedications, only a half are epitaphs. Map on main trade routes?? Lots in Baetica and coastal regions of Spain and France, BAtavia and Limes as well as the Adriatic.

### Remarkable augustales
```{r}
# Publius Decimius Eros Merula or Lucius Lupercius Exessus
EDH_people %>% 
 # filter(grepl("Augustales", status, ignore.case = T)) %>% 
  filter(cognomen == "Eros") %>% 
  select(name, nomen, status)
  #left_join(LIST, by = c("id" = "EDH.ID")) %>% 

```

