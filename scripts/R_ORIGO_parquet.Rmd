---
title: "Origo Parquett"
author: "Adela Sobotkova"
date: "2023-03-23"
output: html_document
---

Visualizing origo dataset:
This script containes facetted maps of origin and destination of the people in EDH inscriptions (92,000 > 3000 placenames> 2277 successfully geocoded ones).
It needs a breakdown by province (DONE) with Sankey diagram mapping from to to by province, to explore flow by time.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(tidyverse)

library(sf)

library(sfarrow)
library(mapview)
```

## Get province, origo and LIRE data

*What are all these datasets? Explanation is needed!*
```{r data}
# Pleiades provinces
romanEmpire <- read_sf("../data/pleiades_regions.geojson") # not great as they collate all province changes over time without identities


# EDH provinces - the best compromise for non-overlapping provincial boundaries
provinceEDH <- read_sf("../data/provinces_valid_BACKUP.geojson")
st_is_valid(provinceEDH) 

# provinceEDH$valid <- sf::st_is_valid(provinceEDH$geometry)
# mapview(provinceEDH, zcol = "valid")

# LIRE
#LIRE <- st_read_parquet("../data/large_data/LIRE_contexts.parquet")

# Origo parquet
origo <- st_read_parquet("../data/origo_geo.parquet")

# paths <- st_read_parquet("../data/origo_linepoints_gdf.parquet")
```

## Birth locations geocoded in the *origo* column

Birth locations were geocoded on the basis of 'placename' in the EDH dataset. This field is unstructured text and suffers from ambiquity, incompleteness, spelling inconsistency and varied levels of granularity. It was first automatically (30% worked) and later manually geocoded (90% of the remaining 70%).

This chunk investigates the frequency and uniqueness of placenames in the origo column as well as their spatial and nomical overlap. While we have 2277 people with geocodable origo, they are named on 1951 inscriptions, mention 1083 placenames, which we have traced (with more or less certainty) to 663 unique physical locations. WHen geocoding, ca 76% of locations are geocoded with certainty, 12% have multiple good variants, 7% are uncertain and 5% represent a wild guess. 
```{r}
# Total amount of people with origo
dim(origo) # 2277 records
head(origo)

# Unique inscriptions (should be lower than 2277 as some have multiple people on an inscription)
origo %>% 
  group_by(hd_nr) %>% 
  tally()
# 1951

# Unique birth locations by coordinates
origo %>% 
  group_by(pleiades_Latitude, pleiades_Longitude) %>% 
  tally()
# 663


# Unique birth locations by origo placename
origo %>% 
  group_by(origo_clean) %>% 
  tally()
# 1083

# Unique pleiades title on origo
origo %>% 
  group_by(pleiades_title) %>% 
  tally()
# 681

# Certainty of origo geocoding
origo %>% 
  group_by(Certainty) %>% 
  tally() %>% 
  mutate(pctCertain = round(n/2277 *100, 2))
  
origo <- origo %>% 
  mutate(certainty = case_when(
   Certainty == "certain" ~ "certain",
   Certainty == "uncertain (name could be interpreted differently)" ~ "uncertain",
   Certainty == "uncertain (another good variant exists)" ~ "uncertain",
   Certainty == "uncertainty is in the latlong source"  ~ "uncertain",
   Certainty == "wild guess" ~ "wild guess"))

# Certainty of origo geocoding
origo %>% 
  group_by(certainty) %>% 
  tally() %>% 
  mutate(pctCertain = round(n/2277 *100, 2))
```

## Death locations

```{r}
colnames(origo)
# Unique death locations THIS IS HIGH
nrow(origo) - length(which(duplicated(origo$edh_point)))

# only 484 unique destinations for all the travellers
```

## Spatial Data Streamlining
Create two point simple features using the point columns in origo. Call origin origo_start coordinates and deathplace origo_end
```{r}
names(origo) # edh point is the active geoemtry
origo_end <- origo %>%
  st_as_sf() %>% 
  st_set_crs(4326) %>% #mapview(zcol = "certainty")
  st_transform(3035)
origo_start <- origo %>%  # switching active geometry to ori
  st_drop_geometry() %>% 
  st_as_sf(coords = c("pleiades_Longitude","pleiades_Latitude"), crs = 4326)  %>% 
  st_transform(3035)

origo_start$origo_point

origo$edh_point # no CRS
origo_end$geometry # is NULL
origo_end$edh_point # contains data
```

### Check province and origo alignment: projection and validity
```{r}
# edh province polygons need clean up - NOT FINISHED
st_crs(provinceEDH) == st_crs(origo_start)
st_crs(provinceEDH) == st_crs(origo_end)

st_is_valid(provinceEDH)

### Province centroids
province_centroid <- st_centroid(provinceEDH)
```

## Make visuals

```{r parquet-leaflet}

# Quick map to see if origo birth points are roughly in place

library(leaflet)

leaflet() %>%

  addTiles() %>%

  addCircles(origo$pleiades_Longitude,

             origo$pleiades_Latitude) %>%

  addPolygons(data = st_transform(provinceEDH, 4326), opacity = 0.2, color = "green")
```
```{r certainty-percent}
# Tally by certainty to see how many were easily geocoded

origo_start %>%
  group_by(certainty) %>%
  tally() %>% 
  mutate(pctGeocodingCertainty = round(n/2277 *100,1))
```

## Prepare for time-series
Iin order to create a facetted view of change over time, we need the century values (present/absent) to be in a single column, and not spread over several columns. Therefore we shall pivot the dataset from wide to longer and compress the individual century columns with T/F values into a single 'century' column with a row for every century the inscription was in existence.
```{r pivot-long}
# See the ~X1BCE fields in the dataset which indicate presence/absense in a given century
names(origo)

unique(origo$certainty)

# Wrangle into a long dataset

origo_end_long <- origo_end %>%  
  select(-origo_line) %>% 
  pivot_longer(cols = X1BCE:X5CE,  # take values from columns and write through True/False
               names_to = "century",
               values_to = "century_logical") %>% 
  filter(century_logical == TRUE)


# Repeat for origo _point geometry

origo_start_long <- origo_start %>%  
  select(-origo_line) %>% 
  pivot_longer(cols = X1BCE:X5CE, 
               names_to = "century",
               values_to = "century_logical") %>% 
  filter(century_logical == TRUE)

```


```{r origo-mapview-certainty}

# Plot the results in mapview so as to see the distribution of certainties in space  


library(mapview) 

mapview(origo_start, zcol = "certainty")
```


### Time-series on origin / birth place

```{r}
# Use timeseries century column as a facet in tmaps
library(tmap)
tmap_options(limits = c(facets.view = 6)) # we want to view 5 periods
tmap_options(check.and.fix = TRUE)
tmap_mode(mode = "view" )

tm_shape(origo_start_long) +
  tm_facets(by = "century",
                ncol=2, nrow = 3)+
  tm_dots("certainty")+
  tm_shape(provinceEDH$geometry)+
  tm_borders(alpha = 0.7)+
  tm_layout(main.title = "Birthplaces of moving people by century",
            legend.outside = F)

```


### Time-series on destination / death place


```{r}

# Use it as a facet in tmaps
library(tmap)
tmap_options(limits = c(facets.view = 6)) # we want to view 5 periods
tmap_options(check.and.fix = TRUE)
tmap_mode(mode = "view" )

tm_shape(origo_end_long) +
  tm_facets(by = "century",
         
            ncol=2, nrow = 3)+
  tm_dots("certainty",
             palette = "magma")+
  tm_shape(provinceEDH)+
  tm_borders(col = "grey",
             alpha = 0.7)+
  tm_layout(main.title = "Final destination of movement",
            legend.outside = TRUE)
```


## Provinces
Here we attach birth and death province names to the origo record and generate summaries of province flow.
```{r}
origo_start_prov <- origo_start %>% 
  st_join(provinceEDH, join = st_intersects, left = TRUE)

origo_end_prov <- origo_end %>% 
  st_join(provinceEDH, join = st_intersects, left = TRUE)

province_start_summary <- origo_start_prov %>% 
  st_drop_geometry() %>% 
  select(province, pleiades_title) %>% 
  group_by(province) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  rename(province_birth = n)

province_end_summary <- origo_end_prov %>% 
  st_drop_geometry() %>% 
  select(province, pleiades_title) %>% 
  group_by(province) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  rename(province_death = n)

province_flow_centroid <- province_centroid %>% 
  left_join(province_end_summary, by = "province") %>% 
  left_join(province_start_summary, by = "province")

province_centroid
province_flow_centroid # this may need to be done in a long format for centuries
```

## Sync maps

```{r}
library(mapview)
library(leafsync)

mapview(province_centroid)
map_origo <- mapview(province_flow_centroid, 
          map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        color = "white", 
        cex = "province_birth",
        legend = TRUE, 
        layer.name = "Birthplaces",
        homebutton = FALSE, lwd = 0.5) 


map_dest <- mapview(province_flow_centroid, 
          map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        color = "white", 
        cex = "province_death",
        legend = TRUE, 
        layer.name = "Deathplaces",
        homebutton = FALSE, lwd = 0.5)


sync(map_origo, map_dest) # maps need to be mapview based not tm_shape based
```

## Distances
## Option A: Reuse Vojtech's linestrings

```{r Vojtech-lines}
# Create linestrings sf from Vojtech's columns
lines <- origo$origo_line %>% 
  st_sf() %>% 
  st_set_crs(4326)
  # works just fine
colnames(origo)
# Connect the linestrings back with data
lines <- cbind(lines, origo[,c(1:9,11:19,24)] %>% st_drop_geometry())

# Quick check
mapview(lines, zcol = "certainty")

# Calculate geodetic distance because continet scale
lines$length_m <- st_length(lines)  # geodetic distance

# Get rid of units and create kms
lines$length_km <- unclass(lines$length_m)/1000  

# Histogram of distances
ggplot(lines, aes(x = length_km))+
  geom_histogram(bins = 100, aes(fill = certainty))+
  ggtitle(label = "Great circle distances between birth and death location by origo geocoding certainty")+
  theme_bw()+
  theme(#legend.title=element_blank(),
        legend.position = c(.85,.75))+
  labs(x = "Distance in kms",
       y = "Number of travellers",
       fill = "Origo coordinates")

ggsave("../figures/orig_dist_certain.png", width = 8, height = 6)
```



### summary
```{r}
summary(lines$length_km)
```

## Option B: Create Birth-Death place linestrings from points

We connect the origo coordinates with findspot coordinates by great circles in geodetic space

```{r}
length(which(st_is_valid(origo_start$origo_point)))==length(which(st_is_valid(origo_end$edh_point)))

test <- st_union(origo_start$origo_point, origo_end$edh_point)
lines <- st_cast(test, "LINESTRING")
st_crs(lines) <- 4326

# The function is neater but does not work with geometry special columns,...yet.
# lines <- st_sfc(mapply(function(a,b){
#   st_cast(st_union(a,b),"LINESTRING")}, 
#   a = origo_start$origo_point,b = origo_end$edh_point, SIMPLIFY = TRUE))
# st_crs(lines) <- 4326

library(mapview) 
mapview(lines)
```


### Calculate as-the-crow-flies distances
Let's calculate great circle distances and differentiate lines by length

```{r line-length}
# Convert lines to sf and calculate length
lines_sf <- st_as_sf(lines)
lines_sf$length <- st_length(lines)

# Convert to km - but beware it is still declared as m
lines_sf$length_km <- unclass(lines_sf$length/1000)

# See the length visualized
mapview(lines_sf, zcol = "length_km")
```

### Let's see the range of distances travelled
If we connect the birth and death places with great circle distances, ignoring roads and other barriers as well as sea travel. All distances are wrong in similar way. Yet, we can assume that dying 500km away from home is serious. So even if it is only 3% people, the distances are substantial and that may be why origo is  mentioned
If the Romans could fly as the crows, these would be their ranges.
```{r}
lines_sf$length_km %>% 
  hist( main = "Great Circle distances from birth region to death region", xlab = "km")
```
```{r}
# average distance traveled
sum(unclass(lines_sf$length_km)) / nrow(origo) #in kilometers not meters
```
## Break down the distances traveled by status and gender
If we add people and inscription data back to the linestrings, we can differentiate the travel by sex, status, occupation, and other social categories. 

To add people into the origo points and linestrings we need to connect origo data to LIRE or EDH data hd_nr at least, but at best to id - the combination of EDH identifier and person identifier.
```{r}
# Bring in people data from EDH
# if newest does not work, use 2021 data in rds
list_json <- jsonlite::fromJSON("../data/large_data/EDH_text_cleaned_2022-11-03.json")  
EDH_tibble <- as_tibble(list_json)

# Rdata of 2021 json EDH tibble
EDH_tibble <- readRDS("../data/large_data/edh_2021.rds")


colnames(EDH_tibble)
EDH_tibble$id

# Select inscriptions whose number matches that in origo
EDH_origo <- EDH_tibble %>%
  filter(id %in% origo$hd_nr) # 2288 inscriptions match but have wrapped people attribute

# Select inscriptions whose number matches one in origo dataset and expand the people attribute
EDH_origo_people <- EDH_tibble %>%
  filter(id %in% origo$hd_nr) %>%  # match origo hr_nr
  dplyr::select(id, people) %>% 
  unpack(cols = c(people))  %>% 
  unnest_wider(people, simplify = F) %>% 
  unnest_longer(c(person_id,name, cognomen, nomen, supernomen, gender, praenomen, `age: years`, `age: months`, `age: days`, `age: hours`, status, occupation, tribus, origo)) 

# Find which of the expanded 4000 people have origo (should be ca 2277)
EDH_origo_people <- EDH_origo_people %>% 
  filter(!is.na(origo)) # 2288 people records in 1930 unique inscriptions
EDH_origo_people %>% group_by(id) 

# Find matching columns in lines geospatial data with EDH people
head(EDH_origo_people)
colnames(EDH_origo_people)


colnames(origo_people)
```

Now that we identified the columns that are shared, we can connect spatial data to personal information to learn about the status and gender of travelers
```{r}
# Create a field that matches id in lines
EDH_origo_people$newid <- paste(EDH_origo_people$id, EDH_origo_people$person_id, sep="/")

# Spatial data inspect
colnames(lines)
head(lines)

# Merge spatial and EDH origo data by person_id
lines_people <- lines %>% 
  left_join(EDH_origo_people, by=c("id" = "newid"))
  #select(matches("pleiades|origo|id|hd|X|type_of|clean_text|point|line|people"))
```

## Visualize distances traveled by status and gender
### Distance and occupation
a fraction of travellers mention their occupation
```{r}
# Show how many travellers provide occupation info
ggplot(lines_people, aes(x = length_km))+
  geom_histogram(bins = 100, aes(fill = occupation))+
  ggtitle(label = "Great Circle distances from birth region to death region")+
  theme_bw()+
  labs(x = "Distance in kms",
       y = "Number of travellers")

ggsave("../figures/orig_dist_occup.png", width = 8, height = 6)


# Show occupations alone
lines_people %>% 
  filter(!is.na(occupation)) %>% 
  ggplot(aes(x = length_km))+
  geom_histogram(bins = 100)+
  ggtitle(label = "Birth to death distances for travellers with occupation (56 out of 2277)")+
  theme_bw()+
  labs(x = "Distance in kms",
       y = "Travellers with an occupation")
```

Traveling individuals rarely state their occupation. Howeer most are soldiers so the occupation is clear. The occupation of others is driven by their social status of being senators ao slaves,..
### Distance and gender
a fraction of women declare origo
```{r}
# Show breakdown of travellers distances by gender
ggplot(lines_people, aes(x = length_km))+
  geom_histogram(bins = 100, aes(fill = gender))+
  ggtitle(label = "Birth to death distances by gender")+
  theme_bw()+
  theme(legend.title=element_blank(),
        legend.position = c(.85,.75))+  # works only after theme_bw()
  labs(x = "Distance in kms",
       y = "Gendered travellers")

ggsave("../figures/orig_dist_gender.png", width = 8, height = 6)
```

```{r eval= FALSE}
# A stacked plot may be better to show if fraction of women increase inversely to distance, however we need a percent column calculated for each distance bin. Distance bins are variable so this is a moving target. ONce you decide on bins, follow this logic:

percent_gender <- lines_people %>%
    group_by(gender, distance_interval) %>%
    mutate(percent = n/sum(gender) * 100) %>%
    ungroup()

ggplot(lines_people, aes(x = length_km))+
  geom_bar(aes(fill = percent_gender))+
  ggtitle(label = "Birth to death distances by gender")+
  theme_bw()+
  labs(x = "Distance in kms",
       y = "Gendered travellers")

```

### Distance by status
```{r}
# Pull the first primary status out of the multi-valued attribute
status <- str_split_fixed(lines_people$status, ";", n=3) %>% 
  as.data.frame()

# Tie status back to lines
lines_status <- cbind(lines_people, status$V1)
colnames(lines_status)

# Clean up mising values and special characters
lines_status <- lines_status %>% 
  filter(!is.na(status)) %>% 
  mutate(status_clean = str_replace_all(string = status.V1, pattern = "\\?", replacement = "")) 

# Plot status by distance
ggplot(data = lines_status,  aes(x = length_km))+
  geom_histogram(bins = 100, aes(fill = status_clean))+
  theme_bw()+
  theme(#legend.title=element_blank(),
        legend.position = c(.85,.75))+
  labs(title = "Birth to death distances differentiated by traveller status (1477 out of 2277)",
       x = "Distance in kms",
       y = "Travellers ", 
       fill = "Primary status")

ggsave("../figures/orig_dist_status.png", width = 8, height = 6)
```
### Faceted plot by status
```{r}
# Plot status by distance
ggplot(data = lines_status,  aes(x = length_km))+
  geom_histogram(bins = 50, aes(fill = certainty))+
  facet_wrap(~ status_clean)+
  theme_bw()+
  theme(legend.position = "bottom")+
  labs(title = "Birth to death distances by traveller status (1477 out of 2277)",
        x = "Distance in kms",
        y = "Traveller count", 
        fill = "Origo location")

ggsave("../figures/orig_dist_occupfac.png", width = 8, height = 6)
```

### What is the status count
```{r}
lines_status %>% 
  st_drop_geometry() %>% 
  filter(!is.na(status_clean)) %>% 
  group_by(status_clean) %>% 
  count() %>% 
  mutate(log=round(log10(n),1)) %>% 
  arrange(desc(log)) %>% 
  #mutate(status_clean = reorder(status_clean, log)) %>% 
  ggplot(aes(y=status_clean, x=log, fill=status_clean)) +
  geom_col(width=0.8, stat="identity") +
  coord_cartesian(xlim=c(0,4)) +
  labs(x = "Number of instances (log10)", y = "Status category", title = "Status references in the origo data", subtitle = ggtitle(paste("n =", nrow(lines_status), "people in inscriptions"))) +
  geom_label(aes(label= n)) +
  theme_linedraw(base_size = 13) +
  theme(legend.position = "none")

ggsave("../figures/Status_origo.png", width = 8, height = 6) 
```


### Frequency counts of travel distance TO DO!
Which travel intervals are taken by what percent of travelers? Follow Kraemer reporting.

## TRAVEL IN TIME by status and gender TO DO!!
Are there more senators in the first 2 centuries and more soldiers in the remaining time? How are statuses and gender distributed?

## Sankey COPIED BUT NOt working YET - ELABORATE!
https://stackoverflow.com/questions/63255589/create-a-sankey-diagram-with-tidy-data-in-r

https://r-charts.com/flow/sankey-diagram-ggplot2/

https://www.kaggle.com/code/paulc91/visualise-flows-with-r-d3/report  # the best resource is here

```{r eval=FALSE}
# Sankey network data preparation

top_orig <- origo_start_prov %>%
  st_drop_geometry() %>% 
  group_by(province) %>% 
  tally() %>% 
  top_n(20, n)

top_dest <- origo_end_prov%>%
  st_drop_geometry() %>% 
  group_by(province) %>% 
  tally() %>% 
  top_n(20, n)

travellers <- origo_start_prov %>% 
  st_drop_geometry() %>% 
  rename(origin=province) %>% 
  left_join(st_drop_geometry(origo_end_prov)[c(1:2,5,22)], by = "id") %>% 
  rename(destination = province) %>% 
  relocate(origin, destination, .before = origo)

# travellers going to the most frequent destinations and from frequent origins
travellers_filtered <- travellers %>% 
  filter(origin %in% top_orig$province,
         destination %in% top_dest$province) %>% 
  select(id, origin, destination, X1CE:X5CE) %>% 
  # filter(X2CE == TRUE) %>%
  # select(-c(X1CE:X5CE)) %>%
  drop_na() %>%
  pivot_longer(cols = X1CE:X5CE, names_to = "century", values_to = "value") %>% 
  count(origin, destination, century, value) %>% 
  spread(value, n, fill = 0) %>%
  select(-'FALSE')
 
  # I would like to summarize by number of movements between provinces per century

travellers_filtered

# summarize the data on birth provinces
b_province <- travellers_filtered %>%
  group_by(origin) %>% 
  tally() %>% 
  rename(source_int = n, source = origin)

# enrich the traveler data with the summaries
df <- travellers_filtered %>%
  filter(century == "X1CE") %>% 
  rename(source = origin, target = destination, target_int = 'TRUE') %>% 
  select(source, target, target_int) %>% 
  left_join(b_province, by = "source") %>% 
  relocate(source_int, .after = source) %>% 
  drop_na() %>% 
  filter(target_int > 10)

df



```


### Sankey plot
```{r eval=FALSE}
# DOES NOT WORK!   
library(ggsankey)
ggplot(df, aes(x = source, 
               next_x = target, 
               node = source_int, 
               next_node = target_int, 
               fill = factor(source_int))) +
  geom_sankey()

```


### GGplot density map 
DOES NOT WORK
Needs - to be cleaned up to white background and contours and provinces in the back

```{r eval=FALSE}
ggplot() +
  stat_density_2d(data = origo_start_long,
                  mapping = aes(x = purrr::map_dbl(origo_start, ~.[1]),
                                y = purrr::map_dbl(origo_start, ~.[2]),
                                fill = stat(density)),
                  geom = "tile",
                  contour = F,
                  alpha = 0.5)+
  facet_wrap(~ century, ncol = 2)
ggplot()+
 # geom_sf(data = provinceEDH, fill = NA)+
  geom_sf(data = origo_long, aes(color = cert)) +
  #scale_fill_viridis_c(option = "magma") +
  theme_bw()

```


