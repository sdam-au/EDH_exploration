---
title: "Origo Parquett"
author: "Adela Sobotkova"
date: "2023-03-23"
output: html_document
---

Visualizing origo dataset:
This script containes facetted maps of origin and destination of the people in EDH inscriptions (92,000 > 3000 placenames> 2277 successfully geocoded ones).
It needs a breakdown by province (DONE) with Sankey diagram mapping from to to by province, to explore flow by time.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


library(tidyverse)

library(sf)

library(sfarrow)
library(mapview)
```

## Get province, origo and LIRE data

*What are all these datasets? Explanation is needed!*
```{r data}
# Pleiades provinces
romanEmpire <- read_sf("../data/pleiades_regions.geojson") # not great as they collate all province changes over time without identities


# EDH provinces - the best compromise for non-overlapping provincial boundaries
provinceEDH <- read_sf("../data/provinces_valid.geojson")
st_is_valid(provinceEDH) 

# provinceEDH$valid <- sf::st_is_valid(provinceEDH$geometry)
# mapview(provinceEDH, zcol = "valid")

# LIRE
LIRE <- st_read_parquet("../data/large_data/LIRE_contexts.parquet")

# Origo parquet
origo <- st_read_parquet("../data/origo_geo.parquet")

paths <- st_read_parquet("../data/origo_linepoints_gdf.parquet")
```

## Birth locations geocoded in the *origo* column

Birth locations were geocoded on the basis of 'placename' in the EDH dataset. This field is unstructured text and suffers from ambiquity, incompleteness, spelling inconsistency and varied levels of granularity. It was first automatically (30% worked) and later manually geocoded (90% of the remaining 70%).

This chunk investigates the frequency and uniqueness of placenames in the origo column as well as their spatial and nomical overlap. While we have 2277 people with geocodable origo, they are named on 1951 inscriptions, mention 1083 placenames, which we have traced (with more or less certainty) to 663 unique physical locations. WHen geocoding, ca 76% of locations are geocoded with certainty, 12% have multiple good variants, 7% are uncertain and 5% represent a wild guess. 
```{r}
# Total amount of people with origo
dim(origo) # 2277 records
head(origo)

# Unique inscriptions (should be lower than 2277 as some have multiple people on an inscription)
origo %>% 
  group_by(hd_nr) %>% 
  tally()
# 1951

# Unique birth locations by coordinates
origo %>% 
  group_by(pleiades_Latitude, pleiades_Longitude) %>% 
  tally()
# 663


# Unique birth locations by origo placename
origo %>% 
  group_by(origo_clean) %>% 
  tally()
# 1083

# Unique pleiades title on origo
origo %>% 
  group_by(pleiades_title) %>% 
  tally()
# 681

# Certainty of origo geocoding
origo %>% 
  group_by(Certainty) %>% 
  tally() %>% 
  mutate(pctCertain = round(n/2277 *100, 2))
  
origo <- origo %>% 
  mutate(certainty = case_when(
   Certainty == "certain" ~ "certain",
   Certainty == "uncertain (name could be interpreted differently)" ~ "uncertain",
   Certainty == "uncertain (another good variant exists)" ~ "uncertain",
   Certainty == "uncertainty is in the latlong source"  ~ "uncertain",
   Certainty == "wild guess" ~ "wild guess"))

# Certainty of origo geocoding
origo %>% 
  group_by(certainty) %>% 
  tally() %>% 
  mutate(pctCertain = round(n/2277 *100, 2))
```

## Death locations

```{r}
colnames(origo)
# Unique death locations THIS IS HIGH
nrow(origo) - length(which(duplicated(origo$edh_point)))

# only 484 unique destinations for all the travellers
```

## Spatial Data Streamlining
### Create simple feature using origo_start coordinates in origo
```{r}
names(origo) # edh point is the active geoemtry
origo_end <- origo %>%
  st_as_sf() %>% 
  st_set_crs(4326) %>% #mapview(zcol = "certainty")
  st_transform(3035)
origo_start <- origo %>%  # switching active geometry to origo_start
  st_drop_geometry() %>% 
  st_as_sf(coords = c("pleiades_Longitude","pleiades_Latitude"), crs = 4326)  %>% 
  st_transform(3035)

origo_start$origo_point

origo$edh_point # no CRS
origo_end$geometry # is NULL
origo_end$edh_point # contains data
```

### Check province and origo alignment: projection and validity
```{r}
# edh province polygons need clean up - NOT FINISHED
st_crs(provinceEDH) == st_crs(origo_start)
st_crs(provinceEDH) == st_crs(origo_end)

st_is_valid(provinceEDH)

# this only fixes 2 out of 8 bad geometries
# provinceEDH %>% 
#   st_make_valid() %>% 
#   st_buffer(0) 


### Province centroids
province_centroid <- st_centroid(provinceEDH)
```

## Make visuals

```{r parquet-leaflet}

# Quick map to see if origo birth points are roughly in place

library(leaflet)

leaflet() %>%

  addTiles() %>%

  addCircles(origo$pleiades_Longitude,

             origo$pleiades_Latitude) %>%

  addPolygons(data = st_transform(provinceEDH, 4326), opacity = 0.2, color = "green")
```
```{r certainty-percent}
# Tally by certainty to see how many were easily geocoded

origo_start %>%
  group_by(certainty) %>%
  tally() %>% 
  mutate(pctGeocodingCertainty = round(n/2277 *100,1))
```

### Prepare for time-series
Iin order to create a facetted view of change over time, we need the century values (present/absent) to be in a single column, and not spread over several columns. Therefore we shall pivot the dataset from wide to longer and compress the individual century columns with T/F values into a single 'century' column with a row for every century the inscription was in existence.
```{r pivot-long}
# See the ~X1BCE fields in the dataset which indicate presence/absense in a given century
names(origo)

unique(origo$certainty)

# Wrangle into a long dataset

origo_end_long <- origo_end %>%  
  select(-origo_line) %>% 
  pivot_longer(cols = X1BCE:X5CE,  # take values from columns and write through True/False
               names_to = "century",
               values_to = "century_logical") %>% 
  filter(century_logical == TRUE)


# Repeat for origo _point geometry

origo_start_long <- origo_start %>%  
  select(-origo_line) %>% 
  pivot_longer(cols = X1BCE:X5CE, 
               names_to = "century",
               values_to = "century_logical") %>% 
  filter(century_logical == TRUE)

```


```{r origo-mapview-certainty}

# Plot the results in mapview so as to see the distribution of certainties in space  


library(mapview) 

mapview(origo_start, zcol = "certainty")
```


## Time-series on origin / birth place

```{r}

# Use it as a facet in tmaps
library(tmap)
tmap_options(limits = c(facets.view = 6)) # we want to view 5 periods
tmap_options(check.and.fix = TRUE)
tmap_mode(mode = "view" )

tm_shape(origo_start_long) +
  tm_facets(by = "century",
                ncol=2, nrow = 3)+
  tm_dots("certainty",
            palette = "magma")+
  tm_shape(provinceEDH)+
  tm_borders(col = "grey",
             alpha = 0.7)+
  tm_layout(main.title = "Birthplaces of moving people by century",
            legend.outside = F)

```


## Time-series on destination / death place


```{r}

# Use it as a facet in tmaps
library(tmap)
tmap_options(limits = c(facets.view = 6)) # we want to view 5 periods
tmap_options(check.and.fix = TRUE)
tmap_mode(mode = "view" )

tm_shape(origo_end_long) +
  tm_facets(by = "century",
         
            ncol=2, nrow = 3)+
  tm_dots("certainty",
             palette = "magma")+
  tm_shape(provinceEDH)+
  tm_borders(col = "grey",
             alpha = 0.7)+
  tm_layout(main.title = "Final destination of movement",
            legend.outside = TRUE)
```


## Provinces
Here we attach birth and death province names to the origo record and generate summaries of province flow.
```{r}
origo_start_prov <- origo_start %>% 
  st_join(provinceEDH, join = st_intersects, left = TRUE)

origo_end_prov <- origo_end %>% 
  st_join(provinceEDH, join = st_intersects, left = TRUE)

province_start_summary <- origo_start_prov %>% 
  st_drop_geometry() %>% 
  select(province, pleiades_title) %>% 
  group_by(province) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  rename(province_birth = n)

province_end_summary <- origo_end_prov %>% 
  st_drop_geometry() %>% 
  select(province, pleiades_title) %>% 
  group_by(province) %>% 
  tally() %>% 
  arrange(desc(n)) %>% 
  rename(province_death = n)

province_flow_centroid <- province_centroid %>% 
  left_join(province_end_summary, by = "province") %>% 
  left_join(province_start_summary, by = "province")

province_centroid
province_flow_centroid # this may need to be done in a long format for centuries
```

## Sync maps

```{r}
library(mapview)
library(leafsync)

mapview(province_centroid)
map_origo <- mapview(province_flow_centroid, 
          map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        color = "white", 
        cex = "province_birth",
        legend = TRUE, 
        layer.name = "Birthplaces",
        homebutton = FALSE, lwd = 0.5) 


map_dest <- mapview(province_flow_centroid, 
          map.types = "OpenStreetMap", 
        col.regions = "#940000", 
        color = "white", 
        cex = "province_death",
        legend = TRUE, 
        layer.name = "Deathplaces",
        homebutton = FALSE, lwd = 0.5)


sync(map_origo, map_dest) # maps need to be mapview based not tm_shape based
```

## Distances
### Reuse Vojtech's linestrings TO DO!!

## Create Birth-Death place linestrings

We connect the origo coordinates with findspot coordinates by great circles in geodetic space

```{r}
length(which(st_is_valid(origo_start$origo_point)))==length(which(st_is_valid(origo_end$edh_point)))

test <- st_union(origo_start$origo_point, origo_end$edh_point)
lines <- st_cast(test, "LINESTRING")
st_crs(lines) <- 4326

# The function is neater but does not work with geometry special columns,...yet.
# lines <- st_sfc(mapply(function(a,b){
#   st_cast(st_union(a,b),"LINESTRING")}, 
#   a = origo_start$origo_point,b = origo_end$edh_point, SIMPLIFY = TRUE))
# st_crs(lines) <- 4326

library(mapview) 
mapview(lines)
```


## Calculate as-the-crow-flies distances
Let's calculate great circle distances and differentiate lines by length

```{r line-length}
# Convert lines to sf and calculate length
lines_sf <- st_as_sf(lines)
lines_sf$length <- st_length(lines)

# Convert to km - but beware it is still declared as m
lines_sf$length_km <- unclass(lines_sf$length/1000)

# See the length visualized
mapview(lines_sf, zcol = "length_km")
```

### Let's see the range of distances travelled
If we connect the birth and death places with great circle distances, ignoring roads and other barriers as well as sea travel. All distances are wrong in similar way. Yet, we can assume that dying 500km away from home is serious. So even if it is only 3% people, the distances are substantial and that may be why origo is  mentioned
If the Romans could fly as the crows, these would be their ranges.
```{r}
lines_sf$length_km %>% 
  hist( main = "Great Circle distances from birth region to death region", xlab = "km")
```
```{r}
# average distance traveled
sum(unclass(lines_sf$length_km)) / nrow(origo) #in kilometers not meters
```
### break down the distances traveled by status and gender TO DO
## Sankey COPIED BUT NOt working YET - ELABORATE!
https://stackoverflow.com/questions/63255589/create-a-sankey-diagram-with-tidy-data-in-r

https://r-charts.com/flow/sankey-diagram-ggplot2/

https://www.kaggle.com/code/paulc91/visualise-flows-with-r-d3/report  # the best resource is here

```{r}
# Sankey network data preparation

top_orig <- origo_start_prov %>%
  st_drop_geometry() %>% 
  group_by(province) %>% 
  tally() %>% 
  top_n(20, n)

top_dest <- origo_end_prov%>%
  st_drop_geometry() %>% 
  group_by(province) %>% 
  tally() %>% 
  top_n(20, n)

travellers <- origo_start_prov %>% 
  st_drop_geometry() %>% 
  rename(origin=province) %>% 
  left_join(st_drop_geometry(origo_end_prov)[c(1:2,5,22)], by = "id") %>% 
  rename(destination = province) %>% 
  relocate(origin, destination, .before = origo)

# travellers going to the most frequent destinations and from frequent origins
travellers_filtered <- travellers %>% 
  filter(origin %in% top_orig$province,
         destination %in% top_dest$province) %>% 
  select(id, origin, destination, X1CE:X5CE) %>% 
  # filter(X2CE == TRUE) %>%
  # select(-c(X1CE:X5CE)) %>%
  drop_na() %>%
  pivot_longer(cols = X1CE:X5CE, names_to = "century", values_to = "value") %>% 
  count(origin, destination, century, value) %>% 
  spread(value, n, fill = 0) %>%
  select(-'FALSE')
 
  # I would like to summarize by number of movements between provinces per century

travellers_filtered

# summarize the data on birth provinces
b_province <- travellers_filtered %>%
  group_by(origin) %>% 
  tally() %>% 
  rename(source_int = n, source = origin)

# enrich the traveler data with the summaries
df <- travellers_filtered %>%
  filter(century == "X1CE") %>% 
  rename(source = origin, target = destination, target_int = 'TRUE') %>% 
  select(source, target, target_int) %>% 
  left_join(b_province, by = "source") %>% 
  relocate(source_int, .after = source) %>% 
  drop_na() %>% 
  filter(target_int > 10)

df



```


### Sankey plot
```{r}
# DOES NOT WORK!   
library(ggsankey)
ggplot(df, aes(x = source, 
               next_x = target, 
               node = source_int, 
               next_node = target_int, 
               fill = factor(source_int))) +
  geom_sankey()

```


### GGplot density map 
DOES NOT WORK
Needs - to be cleaned up to white background and contours and provinces in the back

```{r}
ggplot() +
  stat_density_2d(data = origo_start_long,
                  mapping = aes(x = purrr::map_dbl(origo_start, ~.[1]),
                                y = purrr::map_dbl(origo_start, ~.[2]),
                                fill = stat(density)),
                  geom = "tile",
                  contour = F,
                  alpha = 0.5)+
  facet_wrap(~ century, ncol = 2)
ggplot()+
 # geom_sf(data = provinceEDH, fill = NA)+
  geom_sf(data = origo_long, aes(color = cert)) +
  #scale_fill_viridis_c(option = "magma") +
  theme_bw()

```


